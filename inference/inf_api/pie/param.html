<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>inference.pie.param API documentation</title>
<meta name="description" content="param.py â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>inference.pie.param</code></h1>
</header>
<section id="section-intro">
<p>param.py</p>
<p>Enums and exceptions for parameters and parameterized models.
Base class for parameters.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
param.py

Enums and exceptions for parameters and parameterized models.
Base class for parameters.
&#34;&#34;&#34;

from .autoname import AutoNamed
from .logger import pielog


# TODO:  Py-3.4 added an enum module in the stdlib; use it here.

# Enum for parameter status:
class Status:
    undef, fixed, stepping, varying = list(range(4))


undef, fixed, stepping, varying = \
    Status.undef, Status.fixed, Status.stepping, Status.varying

# Enum for step types:


class StepType:
    lin_steps, log_steps = list(range(2))


lin_steps, log_steps = StepType.lin_steps, StepType.log_steps


# Enum for parameter stepping direction:
class Direction:
    nextd, prevd = list(range(2))


nextd, prevd = Direction.nextd, Direction.prevd


def reverse_direction(drxn):
    &#34;&#34;&#34;Return the enum for the reverse of the passed direction enum.&#34;&#34;&#34;
    if drxn == nextd:
        return prevd
    elif drxn == prevd:
        return nextd
    else:
        raise ValueError(&#34;Invalid stepping direction!&#34;)


# Exceptions:
class ParamError(Exception):
    &#34;&#34;&#34;Base class for parameter exceptions.&#34;&#34;&#34;
    pass


class ParamRangeError(ParamError):
    &#34;&#34;&#34;Exception for parameter out-of-range (setting or stepping).&#34;&#34;&#34;
    pass


class Param(AutoNamed):
    &#34;&#34;&#34;
    A base class for parameters implemented as AutoNamed descriptors.

    This class implements the _report_name method required of AutoNamed
    descriptors.  For a parameter, this defines value and handler method names
    in the containing class allowing multiple instances to have unique state
    and behavior for the parameter.  It also maintains a list of parameter
    names in the containing class.

    This class also implements parameter attribute access.  The
    subclass must set self.handler (in __init__) to the handler class
    that will be used to handle subclass attributes.
    &#34;&#34;&#34;

    def _report_name(self, cls, name):
        # Note that this gets called when the Param instance is
        # created, which happens when the containing *class* is
        # *defined*, not when it is instantiated.  We don&#39;t yet have
        # an *instance* of the containing class to save state in,
        # so we create and hold on to names that will hold the state
        # later, after an instance is created.
        pielog.debug(&#39;Param instance in %s is named %s&#39;, cls, name)
        self.name = name
        self.value_name = &#39;__&#39; + name + &#39;_val&#39;
        self.handler_name = &#39;__&#39; + name + &#39;_hndlr&#39;
        # Keep a list of param names in the class dict.
        try:
            cls.param_names.append(name)
        except AttributeError:
            cls.param_names = [name]

    def __get__(self, inst, owner):
        # On access (via an Inference instance), the arguments will be:
        #   self = This Param instance
        #   inst = The Inference class instance with this param
        #   owner = The Inference class with this param as a class variable
        try:
            # This fails only if the 1st access is to the default value.
            param_value = getattr(inst, self.value_name)
            return param_value
        except AttributeError:
            # On 1st default access, install the default in the instance.
            # This will be the 1st time we know the instance to install
            # the handler in.
            handler = self.handler_class(self, inst)
            setattr(inst, self.handler_name, handler)
            handler.fix(self.default)
            return handler.get_value()

    def __set__(self, inst, value):
        try:
            # This will fail if we have not yet accessed the default value.
            handler = getattr(inst, self.handler_name)
        except AttributeError:
            handler = self.handler_class(self, inst)
            setattr(inst, self.handler_name, handler)
        handler.fix(value)


# The handler base classes maintain the parameter status and value,
# and also handle broadcasts to listeners.
#
# All handlers will have listeners added and deleted the same way,
# but some types of parameters may have to maintain status and
# value differently.  E.g., for a vector param, there probably won&#39;t
# be a &#39;stepped&#39; status.  So we separate out the listener list
# maintenance from status/value maintenance and broadcasting.

class ParamHandler(object):
    &#34;&#34;&#34;
    A base class for handlers, implementing only the most
    basic common behaviors and saving basic state.

    This base class maintains the listener list.  Listener objects
    will be notified of Param events by calls to these methods:
        on_param_change, on_param_use
    Thus listeners must implement these methods.
    &#34;&#34;&#34;

    def __init__(self, param_inst, owner):
        &#34;&#34;&#34;
        Constructor, recording the instance that owns &amp; accesses this handler,
        and the doc string for the associated parameter.
        *** Subclasses should not override __init__; if they do,
        they must call ParamHandler.__init__ or implement the following. ***
        &#34;&#34;&#34;
        self.param_inst = param_inst
        self.name = param_inst.name
        self.owner = owner  # The instance that owns this handler
        self.value_name = param_inst.value_name  # Name of owner&#39;s attribute holding the value
        self.doc = param_inst.doc
        self.listeners = [owner]
        self.init()

    def init(self):
        &#34;&#34;&#34;Subclasses should override this as necessary rather than
        overriding __init___.&#34;&#34;&#34;
        pass

    def add_listener(self, listener):
        if not listener in self.listeners:
            self.listeners.append(listener)

    def del_listener(self, listener):
        try:
            self.listener.remove(listener)
        except ValueError:
            pass


class ScalarParamHandler(ParamHandler):
    &#34;&#34;&#34;
    A base class for scalar-valued parameters.

    A sublcass must set self.value_class to point to the class implementing
    the returned value of the scalar parameter.
    &#34;&#34;&#34;

    def _set_status(self, status):
        # Note it is possible for status to change without value
        # changing, e.g. when a varied param is fixed to its current
        # value.
        old = self.status
        self.status = status
        pielog.debug(&#39;setStatus for %s %s %s&#39;,self.name, old, status)
        for listener in self.listeners:
            listener._on_param_status_change(self, old, status)

# *** Is there a use case for this?
#    def _notifyOfStep(self):
#        for listener in self.listeners:
#            listener._on_param_stepped(self)

    def _set_value(self, value):
        &#34;&#34;&#34;
        Set the value of the parameter, without checking the range.

        This is for internal use where range checking would be redundant.
        &#34;&#34;&#34;
        self._value = self.value_class(value, self)
        setattr(self.owner, self.value_name, self._value)
        for listener in self.listeners:
            listener._on_param_value_change(self.param_inst)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="inference.pie.param.reverse_direction"><code class="name flex">
<span>def <span class="ident">reverse_direction</span></span>(<span>drxn)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the enum for the reverse of the passed direction enum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_direction(drxn):
    &#34;&#34;&#34;Return the enum for the reverse of the passed direction enum.&#34;&#34;&#34;
    if drxn == nextd:
        return prevd
    elif drxn == prevd:
        return nextd
    else:
        raise ValueError(&#34;Invalid stepping direction!&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="inference.pie.param.Direction"><code class="flex name class">
<span>class <span class="ident">Direction</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Direction:
    nextd, prevd = list(range(2))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="inference.pie.param.Direction.nextd"><code class="name">var <span class="ident">nextd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.pie.param.Direction.prevd"><code class="name">var <span class="ident">prevd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="inference.pie.param.Param"><code class="flex name class">
<span>class <span class="ident">Param</span></span>
</code></dt>
<dd>
<div class="desc"><p>A base class for parameters implemented as AutoNamed descriptors.</p>
<p>This class implements the _report_name method required of AutoNamed
descriptors.
For a parameter, this defines value and handler method names
in the containing class allowing multiple instances to have unique state
and behavior for the parameter.
It also maintains a list of parameter
names in the containing class.</p>
<p>This class also implements parameter attribute access.
The
subclass must set self.handler (in <strong>init</strong>) to the handler class
that will be used to handle subclass attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Param(AutoNamed):
    &#34;&#34;&#34;
    A base class for parameters implemented as AutoNamed descriptors.

    This class implements the _report_name method required of AutoNamed
    descriptors.  For a parameter, this defines value and handler method names
    in the containing class allowing multiple instances to have unique state
    and behavior for the parameter.  It also maintains a list of parameter
    names in the containing class.

    This class also implements parameter attribute access.  The
    subclass must set self.handler (in __init__) to the handler class
    that will be used to handle subclass attributes.
    &#34;&#34;&#34;

    def _report_name(self, cls, name):
        # Note that this gets called when the Param instance is
        # created, which happens when the containing *class* is
        # *defined*, not when it is instantiated.  We don&#39;t yet have
        # an *instance* of the containing class to save state in,
        # so we create and hold on to names that will hold the state
        # later, after an instance is created.
        pielog.debug(&#39;Param instance in %s is named %s&#39;, cls, name)
        self.name = name
        self.value_name = &#39;__&#39; + name + &#39;_val&#39;
        self.handler_name = &#39;__&#39; + name + &#39;_hndlr&#39;
        # Keep a list of param names in the class dict.
        try:
            cls.param_names.append(name)
        except AttributeError:
            cls.param_names = [name]

    def __get__(self, inst, owner):
        # On access (via an Inference instance), the arguments will be:
        #   self = This Param instance
        #   inst = The Inference class instance with this param
        #   owner = The Inference class with this param as a class variable
        try:
            # This fails only if the 1st access is to the default value.
            param_value = getattr(inst, self.value_name)
            return param_value
        except AttributeError:
            # On 1st default access, install the default in the instance.
            # This will be the 1st time we know the instance to install
            # the handler in.
            handler = self.handler_class(self, inst)
            setattr(inst, self.handler_name, handler)
            handler.fix(self.default)
            return handler.get_value()

    def __set__(self, inst, value):
        try:
            # This will fail if we have not yet accessed the default value.
            handler = getattr(inst, self.handler_name)
        except AttributeError:
            handler = self.handler_class(self, inst)
            setattr(inst, self.handler_name, handler)
        handler.fix(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="inference.pie.autoname.AutoNamed" href="autoname.html#inference.pie.autoname.AutoNamed">AutoNamed</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="inference.pie.realparam.RealParam" href="realparam.html#inference.pie.realparam.RealParam">RealParam</a></li>
</ul>
</dd>
<dt id="inference.pie.param.ParamError"><code class="flex name class">
<span>class <span class="ident">ParamError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for parameter exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamError(Exception):
    &#34;&#34;&#34;Base class for parameter exceptions.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="inference.pie.param.ParamRangeError" href="#inference.pie.param.ParamRangeError">ParamRangeError</a></li>
<li><a title="inference.pie.signalmodel.StopStepping" href="signalmodel.html#inference.pie.signalmodel.StopStepping">StopStepping</a></li>
</ul>
</dd>
<dt id="inference.pie.param.ParamHandler"><code class="flex name class">
<span>class <span class="ident">ParamHandler</span></span>
<span>(</span><span>param_inst, owner)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for handlers, implementing only the most
basic common behaviors and saving basic state.</p>
<p>This base class maintains the listener list.
Listener objects
will be notified of Param events by calls to these methods:
on_param_change, on_param_use
Thus listeners must implement these methods.</p>
<p>Constructor, recording the instance that owns &amp; accesses this handler,
and the doc string for the associated parameter.
<strong><em> Subclasses should not override <strong>init</strong>; if they do,
they must call ParamHandler.<strong>init</strong> or implement the following. </em></strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamHandler(object):
    &#34;&#34;&#34;
    A base class for handlers, implementing only the most
    basic common behaviors and saving basic state.

    This base class maintains the listener list.  Listener objects
    will be notified of Param events by calls to these methods:
        on_param_change, on_param_use
    Thus listeners must implement these methods.
    &#34;&#34;&#34;

    def __init__(self, param_inst, owner):
        &#34;&#34;&#34;
        Constructor, recording the instance that owns &amp; accesses this handler,
        and the doc string for the associated parameter.
        *** Subclasses should not override __init__; if they do,
        they must call ParamHandler.__init__ or implement the following. ***
        &#34;&#34;&#34;
        self.param_inst = param_inst
        self.name = param_inst.name
        self.owner = owner  # The instance that owns this handler
        self.value_name = param_inst.value_name  # Name of owner&#39;s attribute holding the value
        self.doc = param_inst.doc
        self.listeners = [owner]
        self.init()

    def init(self):
        &#34;&#34;&#34;Subclasses should override this as necessary rather than
        overriding __init___.&#34;&#34;&#34;
        pass

    def add_listener(self, listener):
        if not listener in self.listeners:
            self.listeners.append(listener)

    def del_listener(self, listener):
        try:
            self.listener.remove(listener)
        except ValueError:
            pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="inference.pie.param.ScalarParamHandler" href="#inference.pie.param.ScalarParamHandler">ScalarParamHandler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="inference.pie.param.ParamHandler.add_listener"><code class="name flex">
<span>def <span class="ident">add_listener</span></span>(<span>self, listener)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_listener(self, listener):
    if not listener in self.listeners:
        self.listeners.append(listener)</code></pre>
</details>
</dd>
<dt id="inference.pie.param.ParamHandler.del_listener"><code class="name flex">
<span>def <span class="ident">del_listener</span></span>(<span>self, listener)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_listener(self, listener):
    try:
        self.listener.remove(listener)
    except ValueError:
        pass</code></pre>
</details>
</dd>
<dt id="inference.pie.param.ParamHandler.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subclasses should override this as necessary rather than
overriding __init___.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self):
    &#34;&#34;&#34;Subclasses should override this as necessary rather than
    overriding __init___.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="inference.pie.param.ParamRangeError"><code class="flex name class">
<span>class <span class="ident">ParamRangeError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception for parameter out-of-range (setting or stepping).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamRangeError(ParamError):
    &#34;&#34;&#34;Exception for parameter out-of-range (setting or stepping).&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="inference.pie.param.ParamError" href="#inference.pie.param.ParamError">ParamError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="inference.pie.param.ScalarParamHandler"><code class="flex name class">
<span>class <span class="ident">ScalarParamHandler</span></span>
<span>(</span><span>param_inst, owner)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for scalar-valued parameters.</p>
<p>A sublcass must set self.value_class to point to the class implementing
the returned value of the scalar parameter.</p>
<p>Constructor, recording the instance that owns &amp; accesses this handler,
and the doc string for the associated parameter.
<strong><em> Subclasses should not override <strong>init</strong>; if they do,
they must call ParamHandler.<strong>init</strong> or implement the following. </em></strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScalarParamHandler(ParamHandler):
    &#34;&#34;&#34;
    A base class for scalar-valued parameters.

    A sublcass must set self.value_class to point to the class implementing
    the returned value of the scalar parameter.
    &#34;&#34;&#34;

    def _set_status(self, status):
        # Note it is possible for status to change without value
        # changing, e.g. when a varied param is fixed to its current
        # value.
        old = self.status
        self.status = status
        pielog.debug(&#39;setStatus for %s %s %s&#39;,self.name, old, status)
        for listener in self.listeners:
            listener._on_param_status_change(self, old, status)

# *** Is there a use case for this?
#    def _notifyOfStep(self):
#        for listener in self.listeners:
#            listener._on_param_stepped(self)

    def _set_value(self, value):
        &#34;&#34;&#34;
        Set the value of the parameter, without checking the range.

        This is for internal use where range checking would be redundant.
        &#34;&#34;&#34;
        self._value = self.value_class(value, self)
        setattr(self.owner, self.value_name, self._value)
        for listener in self.listeners:
            listener._on_param_value_change(self.param_inst)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="inference.pie.param.ParamHandler" href="#inference.pie.param.ParamHandler">ParamHandler</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="inference.pie.realparam.RealParamHandler" href="realparam.html#inference.pie.realparam.RealParamHandler">RealParamHandler</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="inference.pie.param.ParamHandler" href="#inference.pie.param.ParamHandler">ParamHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="inference.pie.param.ParamHandler.init" href="#inference.pie.param.ParamHandler.init">init</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="inference.pie.param.Status"><code class="flex name class">
<span>class <span class="ident">Status</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Status:
    undef, fixed, stepping, varying = list(range(4))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="inference.pie.param.Status.fixed"><code class="name">var <span class="ident">fixed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.pie.param.Status.stepping"><code class="name">var <span class="ident">stepping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.pie.param.Status.undef"><code class="name">var <span class="ident">undef</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.pie.param.Status.varying"><code class="name">var <span class="ident">varying</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="inference.pie.param.StepType"><code class="flex name class">
<span>class <span class="ident">StepType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StepType:
    lin_steps, log_steps = list(range(2))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="inference.pie.param.StepType.lin_steps"><code class="name">var <span class="ident">lin_steps</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.pie.param.StepType.log_steps"><code class="name">var <span class="ident">log_steps</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="inference.pie" href="index.html">inference.pie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="inference.pie.param.reverse_direction" href="#inference.pie.param.reverse_direction">reverse_direction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="inference.pie.param.Direction" href="#inference.pie.param.Direction">Direction</a></code></h4>
<ul class="">
<li><code><a title="inference.pie.param.Direction.nextd" href="#inference.pie.param.Direction.nextd">nextd</a></code></li>
<li><code><a title="inference.pie.param.Direction.prevd" href="#inference.pie.param.Direction.prevd">prevd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="inference.pie.param.Param" href="#inference.pie.param.Param">Param</a></code></h4>
</li>
<li>
<h4><code><a title="inference.pie.param.ParamError" href="#inference.pie.param.ParamError">ParamError</a></code></h4>
</li>
<li>
<h4><code><a title="inference.pie.param.ParamHandler" href="#inference.pie.param.ParamHandler">ParamHandler</a></code></h4>
<ul class="">
<li><code><a title="inference.pie.param.ParamHandler.add_listener" href="#inference.pie.param.ParamHandler.add_listener">add_listener</a></code></li>
<li><code><a title="inference.pie.param.ParamHandler.del_listener" href="#inference.pie.param.ParamHandler.del_listener">del_listener</a></code></li>
<li><code><a title="inference.pie.param.ParamHandler.init" href="#inference.pie.param.ParamHandler.init">init</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="inference.pie.param.ParamRangeError" href="#inference.pie.param.ParamRangeError">ParamRangeError</a></code></h4>
</li>
<li>
<h4><code><a title="inference.pie.param.ScalarParamHandler" href="#inference.pie.param.ScalarParamHandler">ScalarParamHandler</a></code></h4>
</li>
<li>
<h4><code><a title="inference.pie.param.Status" href="#inference.pie.param.Status">Status</a></code></h4>
<ul class="">
<li><code><a title="inference.pie.param.Status.fixed" href="#inference.pie.param.Status.fixed">fixed</a></code></li>
<li><code><a title="inference.pie.param.Status.stepping" href="#inference.pie.param.Status.stepping">stepping</a></code></li>
<li><code><a title="inference.pie.param.Status.undef" href="#inference.pie.param.Status.undef">undef</a></code></li>
<li><code><a title="inference.pie.param.Status.varying" href="#inference.pie.param.Status.varying">varying</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="inference.pie.param.StepType" href="#inference.pie.param.StepType">StepType</a></code></h4>
<ul class="">
<li><code><a title="inference.pie.param.StepType.lin_steps" href="#inference.pie.param.StepType.lin_steps">lin_steps</a></code></li>
<li><code><a title="inference.pie.param.StepType.log_steps" href="#inference.pie.param.StepType.log_steps">log_steps</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>