<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>inference.pie.signalmodel API documentation</title>
<meta name="description" content="Parameterized signal model base class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>inference.pie.signalmodel</code></h1>
</header>
<section id="section-intro">
<p>Parameterized signal model base class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Parameterized signal model base class.
&#34;&#34;&#34;

from .param import *
from .autoname import HasAutoNamed

# Exception for running out of steps:
class StopStepping(ParamError):
    &#34;&#34;&#34;Exception for attempting to step model params beyond the last set.&#34;&#34;&#34;
    pass

class SignalModel(HasAutoNamed):
    &#34;&#34;&#34;
    Base class for parameterized signal models.  This must be mixed in with a
    subclass of the Inference base class that actually oversees most of the
    parameter bookkeeping.
    
    Users must override *signal* and optionally *signals*.
    &#34;&#34;&#34;
    # ??? Should we require signal if signals is defined?

    # *** Note that none of the param state-monitoring methods can
    # be defined to use *predictor* parameters (they won&#39;t exist in the
    # user&#39;s SignalModel subclass).  Is this a
    # significant limitation?  Predictor parameters should
    # not affect calculation of the signal, so I don&#39;t think
    # it&#39;s a significant limitation.

    def signal(self, *args):
        &#34;&#34;&#34;
        Override this method to return the value(s) defined by the model.
        
        To calculate them, access the parameter values as attributes of self
        (e.g., &#34;self.theta&#34;).  The arguments to this method should be quantities
        *other than* the model parameters needed for evaluating the model, 
        e.g., the abscissa at which a fitted function is being evaluated.
        &#34;&#34;&#34;
        raise NotImplementedError

    def signals(self, argvec):
        &#34;&#34;&#34;
        Override this method to return the value(s) defined by the model for
        a vector containing many sets of arguments for the model.  Use vector
        operations, ufuncs, or custom extensions to accelerate the calculation.
        &#34;&#34;&#34;
        raise NotImplementedError

    def on_param_change(self, param):
        &#34;&#34;&#34;
        Note when the value of a parameter is changed.
        
        Override this if work must be done whenever a param value changes; the
        most common scenario where this may be the case is when the allowed 
        ranges of the parameters are coupled, in which case a check for
        parameter validity should be implemented via this method.  Another use
        case is when derived parameter values (that are not Param instances)
        must be updated.
        
        More common model setup chores, such as initializing interpolators,
        should be implemented via on_use, since such setup work is usually not
        necessary until actually evaluating model output, which may not happen
        until after several parameters are changed.
        
        Do *not* assign any parameters in this method; this will cause
        runaway recursive calling of `on_param_change`.
        &#34;&#34;&#34;
        pass

    def on_use(self):
        &#34;&#34;&#34;
        Called when the parameters of the model actually get *used* for
        calculating model signal values.  Override this, e.g., to initialize a
        table lookup or interpolator, or to do other &#34;setup&#34; work that need not
        change when the model value is evaluated for different arguments.
        &#34;&#34;&#34;
        pass

    def _on_param_value_change(self, param):
        &#34;&#34;&#34;
        A &#34;buffer&#34; between internal calls and the user&#39;s on_param_change
        method, insulating the user from maintaining on_use_done.
        &#34;&#34;&#34;
        self.on_use_done = False
        self.on_param_change(param)

    def _on_use(self):
        &#34;&#34;&#34;
        A &#34;buffer&#34; between internal calls and the user&#39;s on_use method,
        insulating the user from maintaining on_use_done.
        &#34;&#34;&#34;
        self.on_use()
        self.on_use_done = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="inference.pie.signalmodel.SignalModel"><code class="flex name class">
<span>class <span class="ident">SignalModel</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for parameterized signal models.
This must be mixed in with a
subclass of the Inference base class that actually oversees most of the
parameter bookkeeping.</p>
<p>Users must override <em>signal</em> and optionally <em>signals</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalModel(HasAutoNamed):
    &#34;&#34;&#34;
    Base class for parameterized signal models.  This must be mixed in with a
    subclass of the Inference base class that actually oversees most of the
    parameter bookkeeping.
    
    Users must override *signal* and optionally *signals*.
    &#34;&#34;&#34;
    # ??? Should we require signal if signals is defined?

    # *** Note that none of the param state-monitoring methods can
    # be defined to use *predictor* parameters (they won&#39;t exist in the
    # user&#39;s SignalModel subclass).  Is this a
    # significant limitation?  Predictor parameters should
    # not affect calculation of the signal, so I don&#39;t think
    # it&#39;s a significant limitation.

    def signal(self, *args):
        &#34;&#34;&#34;
        Override this method to return the value(s) defined by the model.
        
        To calculate them, access the parameter values as attributes of self
        (e.g., &#34;self.theta&#34;).  The arguments to this method should be quantities
        *other than* the model parameters needed for evaluating the model, 
        e.g., the abscissa at which a fitted function is being evaluated.
        &#34;&#34;&#34;
        raise NotImplementedError

    def signals(self, argvec):
        &#34;&#34;&#34;
        Override this method to return the value(s) defined by the model for
        a vector containing many sets of arguments for the model.  Use vector
        operations, ufuncs, or custom extensions to accelerate the calculation.
        &#34;&#34;&#34;
        raise NotImplementedError

    def on_param_change(self, param):
        &#34;&#34;&#34;
        Note when the value of a parameter is changed.
        
        Override this if work must be done whenever a param value changes; the
        most common scenario where this may be the case is when the allowed 
        ranges of the parameters are coupled, in which case a check for
        parameter validity should be implemented via this method.  Another use
        case is when derived parameter values (that are not Param instances)
        must be updated.
        
        More common model setup chores, such as initializing interpolators,
        should be implemented via on_use, since such setup work is usually not
        necessary until actually evaluating model output, which may not happen
        until after several parameters are changed.
        
        Do *not* assign any parameters in this method; this will cause
        runaway recursive calling of `on_param_change`.
        &#34;&#34;&#34;
        pass

    def on_use(self):
        &#34;&#34;&#34;
        Called when the parameters of the model actually get *used* for
        calculating model signal values.  Override this, e.g., to initialize a
        table lookup or interpolator, or to do other &#34;setup&#34; work that need not
        change when the model value is evaluated for different arguments.
        &#34;&#34;&#34;
        pass

    def _on_param_value_change(self, param):
        &#34;&#34;&#34;
        A &#34;buffer&#34; between internal calls and the user&#39;s on_param_change
        method, insulating the user from maintaining on_use_done.
        &#34;&#34;&#34;
        self.on_use_done = False
        self.on_param_change(param)

    def _on_use(self):
        &#34;&#34;&#34;
        A &#34;buffer&#34; between internal calls and the user&#39;s on_use method,
        insulating the user from maintaining on_use_done.
        &#34;&#34;&#34;
        self.on_use()
        self.on_use_done = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="inference.pie.autoname.HasAutoNamed" href="autoname.html#inference.pie.autoname.HasAutoNamed">HasAutoNamed</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="inference.pie.signalmodel.SignalModel.on_param_change"><code class="name flex">
<span>def <span class="ident">on_param_change</span></span>(<span>self, param)</span>
</code></dt>
<dd>
<div class="desc"><p>Note when the value of a parameter is changed.</p>
<p>Override this if work must be done whenever a param value changes; the
most common scenario where this may be the case is when the allowed
ranges of the parameters are coupled, in which case a check for
parameter validity should be implemented via this method.
Another use
case is when derived parameter values (that are not Param instances)
must be updated.</p>
<p>More common model setup chores, such as initializing interpolators,
should be implemented via on_use, since such setup work is usually not
necessary until actually evaluating model output, which may not happen
until after several parameters are changed.</p>
<p>Do <em>not</em> assign any parameters in this method; this will cause
runaway recursive calling of <code>on_param_change</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_param_change(self, param):
    &#34;&#34;&#34;
    Note when the value of a parameter is changed.
    
    Override this if work must be done whenever a param value changes; the
    most common scenario where this may be the case is when the allowed 
    ranges of the parameters are coupled, in which case a check for
    parameter validity should be implemented via this method.  Another use
    case is when derived parameter values (that are not Param instances)
    must be updated.
    
    More common model setup chores, such as initializing interpolators,
    should be implemented via on_use, since such setup work is usually not
    necessary until actually evaluating model output, which may not happen
    until after several parameters are changed.
    
    Do *not* assign any parameters in this method; this will cause
    runaway recursive calling of `on_param_change`.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="inference.pie.signalmodel.SignalModel.on_use"><code class="name flex">
<span>def <span class="ident">on_use</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the parameters of the model actually get <em>used</em> for
calculating model signal values.
Override this, e.g., to initialize a
table lookup or interpolator, or to do other "setup" work that need not
change when the model value is evaluated for different arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_use(self):
    &#34;&#34;&#34;
    Called when the parameters of the model actually get *used* for
    calculating model signal values.  Override this, e.g., to initialize a
    table lookup or interpolator, or to do other &#34;setup&#34; work that need not
    change when the model value is evaluated for different arguments.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="inference.pie.signalmodel.SignalModel.signal"><code class="name flex">
<span>def <span class="ident">signal</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Override this method to return the value(s) defined by the model.</p>
<p>To calculate them, access the parameter values as attributes of self
(e.g., "self.theta").
The arguments to this method should be quantities
<em>other than</em> the model parameters needed for evaluating the model,
e.g., the abscissa at which a fitted function is being evaluated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal(self, *args):
    &#34;&#34;&#34;
    Override this method to return the value(s) defined by the model.
    
    To calculate them, access the parameter values as attributes of self
    (e.g., &#34;self.theta&#34;).  The arguments to this method should be quantities
    *other than* the model parameters needed for evaluating the model, 
    e.g., the abscissa at which a fitted function is being evaluated.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="inference.pie.signalmodel.SignalModel.signals"><code class="name flex">
<span>def <span class="ident">signals</span></span>(<span>self, argvec)</span>
</code></dt>
<dd>
<div class="desc"><p>Override this method to return the value(s) defined by the model for
a vector containing many sets of arguments for the model.
Use vector
operations, ufuncs, or custom extensions to accelerate the calculation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signals(self, argvec):
    &#34;&#34;&#34;
    Override this method to return the value(s) defined by the model for
    a vector containing many sets of arguments for the model.  Use vector
    operations, ufuncs, or custom extensions to accelerate the calculation.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="inference.pie.signalmodel.StopStepping"><code class="flex name class">
<span>class <span class="ident">StopStepping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception for attempting to step model params beyond the last set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopStepping(ParamError):
    &#34;&#34;&#34;Exception for attempting to step model params beyond the last set.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="inference.pie.param.ParamError" href="param.html#inference.pie.param.ParamError">ParamError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="inference.pie" href="index.html">inference.pie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="inference.pie.signalmodel.SignalModel" href="#inference.pie.signalmodel.SignalModel">SignalModel</a></code></h4>
<ul class="">
<li><code><a title="inference.pie.signalmodel.SignalModel.on_param_change" href="#inference.pie.signalmodel.SignalModel.on_param_change">on_param_change</a></code></li>
<li><code><a title="inference.pie.signalmodel.SignalModel.on_use" href="#inference.pie.signalmodel.SignalModel.on_use">on_use</a></code></li>
<li><code><a title="inference.pie.signalmodel.SignalModel.signal" href="#inference.pie.signalmodel.SignalModel.signal">signal</a></code></li>
<li><code><a title="inference.pie.signalmodel.SignalModel.signals" href="#inference.pie.signalmodel.SignalModel.signals">signals</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="inference.pie.signalmodel.StopStepping" href="#inference.pie.signalmodel.StopStepping">StopStepping</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>