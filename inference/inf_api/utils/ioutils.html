<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>inference.utils.ioutils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>inference.utils.ioutils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import os.path as path
import pickle as pkl
from numpy import ndarray, savez, load

__all__ = [&#39;backup&#39;, &#39;safe_open&#39;, &#39;ArrayStore&#39;, &#39;AttrStore&#39;]

def backup(fname):
    &#34;&#34;&#34;
    Backup any existing file with name fname, up to two levels.  If a
    file fname exists, the existing copy is renamed with a &#39;%&#39;appended
    to its name.  If such a backup already exists, it is renamed with an
    additional &#39;%&#39; appended, overwriting any previous such file.
    &#34;&#34;&#34;
    if path.exists(fname):
        bname = fname + &#39;%&#39;
        if path.exists(bname):
            bbname = bname + &#39;%&#39;
            os.rename(bname, bbname)
        os.rename(fname, bname)

def safe_open(fname, binary=False, opener=None, *args, **kwds):
    &#34;&#34;&#34;
    Open a file by name for writing, backing up an existing version up
    to two levels.  If the file exists, the existing copy is renamed with
    a &#39;%&#39;appended to its name.  If such a backup already exists, it is
    renamed with an additional &#39;%&#39; added, overwriting any previous such
    file.  Return the opened file object.

    By default, the file is opened with the `open` built-in, with &#39;w&#39;
    mode.  If `opener` is specified, it is used to open the file,
    passing any additional arguments after the file name.
    &#34;&#34;&#34;
    backup(fname)
    if opener:
        if args:
            fobj = opener(fname, *args, **kwds)
        else:
            fobj = opener(fname)
    else:
        if binary is True or binary == &#39;b&#39;:
            fobj = open(fname, &#39;wb&#39;)
        else:
            fobj = open(fname, &#39;w&#39;)
    return fobj

def read_column_vectors(dfile, types, as_arrays=True):
    &#34;&#34;&#34;
    Read vectors of scalar-valued data stored as whitespace-delimited strings
    in columns in an open file.  Return a list of vectors storing the values
    read from each column.
    
    The file is presumed open so that header lines can be discarded as needed
    before calling read_vectors().
    
    `types` is a list of callables, one for each column, that convert a
    string representation of a scalar into the actual value.
    
    If `as_arrays` is True, the returned values are Numpy arrays.
    
    If all columns are of the same type, similar capability is available from
    numpy.loadtxt with unpack=True, or by reading rows as records and
    extracting vectors from the resulting array of records.
    &#34;&#34;&#34;

    # TODO:  Replace with numpy.loadtxt?
    # TODO:  Add skiprows, usecols as in loadtxt?
    # TODO:  Use csv; add delimiter as in loadtxt?

    nc = len(types)
    cols = [[] for i in range(nc)]  # list of nc empty lists
    for line in dfile.readlines():
        words = line.strip().split()
        for i in range(nc):
            cols[i].append(types[i](words[i]))
    if as_arrays:
        for i in range(nc):
            cols[i] = array(cols[i])
    return [cols[i] for i in range(nc)]


class ArrayStore(object):
    &#34;&#34;&#34;
    A container class that provides lazy persistance of array instance
    attributes via NumPy&#39;s .npz archives.

    This is doubly lazy:  arrays are not read into the namespace until
    actually requested, and they are not saved to the archive until the
    ArrayStore is explicitly saved.
    &#34;&#34;&#34;

    # *** Is loading really lazy, i.e., does NumPy&#39;s load() read in array data
    # before actual access via dict lookup?

    # TODO:  Perhaps have a __del__ method that saves on deletion?
    # It would have to handle fname=None gracefully.
    # Perhaps an init arg should specify whether to save on deletion.

    # TODO:  Support creating with a name to a non-existing file;
    # subsequent &#34;save()&#34; will use the stored name.

    def __init__(self, fname=None):
        &#34;&#34;&#34;
        Prepare to load arrays from storage if a file name is provided;
        otherwise support saving of arrays assigned as attributes.
        &#34;&#34;&#34;
        # All internal attributes start with &#39;_&#39; to avoid __setattr__
        # array filtering.
        if fname:
            if not fname.endswith(&#39;.npz&#39;):
                fname = fname + &#39;.npz&#39;
                self._npz = load(fname)
        else:
            self._npz = None
        self._fname = fname
        self._archived = {}  # arrays pulled from the archive
        self._new = {}  # arrays to be archived

    def __getattr__(self, name):
        &#34;&#34;&#34;
        Catch references to array attributes that have not yet been
        loaded from the archive.
        &#34;&#34;&#34;
        # This is called only if name is not already in the instance dict.
        if self._npz is None:  # no archive to grab attribute from
            raise AttributeError(name)
        else:  # get value from archive and keep a reference to it
            try:
                value = self._npz[name]
                # Set the attribute directly so __setattr__ won&#39;t add it
                # to self.new.
                object.__setattr__(self, name, value)
                self._archived[name] = value
                return value
            except:
                raise AttributeError(name)

    def __setattr__(self, name, value):
        &#34;&#34;&#34;
        Catch assignments to new attributes, marking them for saving when
        the store is next saved.

        Names starting with &#39;_&#39; have their corresponding attributes set
        without marking; such names are intended for internal use only,
        to keep track of the state of the store.
        &#34;&#34;&#34;
        # *** Should this prevent over-writing existing names, either
        # directly assigned or yet to be loaded from the archive?
        # Right now we allow reassignments; saving will save the
        # reassigned value.
        if name.startswith(&#39;_&#39;):
            object.__setattr__(self, name, value)
        elif isinstance(value, ndarray):
            self._new[name] = value
            object.__setattr__(self, name, value)
        else:
            raise ValueError(&#39;Only ndarray objects may be stored!&#39;)

    def save(self, fname=None):
        &#34;&#34;&#34;
        Save array attributes to a NumPy .npz archive.  If a name is
        provided, it is used (adding &#39;.npz&#39; if needed); otherwise it is
        presumed this store was created from an existing archive, and
        that archive&#39;s name is used.

        In either case, any existing version is backed up before the
        new one is created, with up to two levels of backups (with &#39;%&#39;
        and &#39;%%&#39; suffixes).
        &#34;&#34;&#34;
        # *** Perhaps this should be called by __del__; or this possibility
        # could be set by a flag on init???

        # If no name given, use the name provided at creation.
        if fname is None:
            if self._fname is None:
                raise ValueError(&#39;Need a file name for saving!&#39;)
            fname = self._fname
        else:
            if not fname.endswith(&#39;.npz&#39;):
                fname = fname + &#39;.npz&#39;
        # Gather arrays to store; note new versions supersede old ones.
        arrays = {}
        for name, val in list(self._archived.items()):
            arrays[name] = val
        # Don&#39;t forget to get any archived values not already accessed.
        if self._npz:
            for name in self._npz.files:
                if name not in self._archived:
                    arrays[name] = self._npz[name]
        for name, val in list(self._new.items()):
            arrays[name] = val
        # Backup any existing file, and save the arrays to a new file.
        backup(fname)
        savez(fname, **arrays)

    def contents(self):
        &#34;&#34;&#34;
        List the names of arrays accessible by this store, including
        both previously archived arrays and newly defined arrays.
        &#34;&#34;&#34;
        names = []
        if self._npz:
            names.extend(self._npz.files)  # archive file names will be array names
        names.extend(list(self._new.values()))
        return names


class AttrStore(object):
    &#34;&#34;&#34;
    A container class that provides lazy persistance of instance attributes
    as a Python pickle.

    This is doubly lazy:  attributes are not placed in the namespace until
    actually requested, and they are not saved to the archive until the
    AttrStore is explicitly saved.
    
    If only NumPy arrays are to be stored, ArrayStore may be more efficient.
    &#34;&#34;&#34;

    # *** Is there any virtue to laziness in loading the namespace, since
    # we aren&#39;t unpacking a NumPy npz file archive?

    # TODO:  Perhaps have a __del__ method that saves on deletion?
    # It would have to handle fname=None gracefully.
    # Perhaps an init arg should specify whether to save on deletion.

    # TODO:  Support creating with a name to a non-existing file;
    # subsequent &#34;save()&#34; will use the stored name.
    
    # TODO:  Add kwd args to init for setting attributes to store.

    def __init__(self, fname=None, **kwds):
        &#34;&#34;&#34;
        Prepare to load attributes from storage if a file name is provided;
        otherwise support saving of arrays assigned as attributes.
        &#34;&#34;&#34;
        # All internal attributes start with &#39;_&#39; to avoid __setattr__
        # array filtering.
        if fname:
            if not fname.endswith(&#39;.pkl&#39;):
                fname = fname + &#39;.pkl&#39;
                ifile = open(fname, &#39;rb&#39;)
                self._archive = pkl.load(ifile)
                ifile.close()
        else:
            self._archive = None
        self._fname = fname
        self._pulled = {}  # attributes pulled from the archive
        self._new = {}  # attributes to be archived
        if kwds:
            for key, value in list(kwds.items()):
                setattr(self, key, value)

    def __getattr__(self, name):
        &#34;&#34;&#34;
        Catch references to attributes that have not yet been loaded from
        the store.
        &#34;&#34;&#34;
        # This is called only if name is not already in the instance dict.
        if self._archive is None:  # no archive to grab attribute from
            raise AttributeError(name)
        else:  # get value from archive and keep a reference to it
            try:
                value = self._archive[name]
                # Set the attribute directly so __setattr__ won&#39;t add it
                # to self.new.
                object.__setattr__(self, name, value)
                self._pulled[name] = value
                return value
            except:
                raise AttributeError(name)

    def __setattr__(self, name, value):
        &#34;&#34;&#34;
        Catch assignments to new attributes, marking them for saving when
        the store is next saved.

        Names starting with &#39;_&#39; have their corresponding attributes set
        without marking; such names are intended for internal use only,
        to keep track of the state of the store.
        &#34;&#34;&#34;
        # *** Should this prevent over-writing existing names, either
        # directly assigned or yet to be loaded from the archive?
        # Right now we allow reassignments; saving will save the
        # reassigned value.
        if name.startswith(&#39;_&#39;):
            object.__setattr__(self, name, value)
        else:
            self._new[name] = value
            object.__setattr__(self, name, value)

    def save(self, fname=None):
        &#34;&#34;&#34;
        Save attributes to a high-protocol pickle.  If a name is
        provided, it is used (adding &#39;.pkl&#39; if needed); otherwise it is
        presumed this store was created from an existing archive, and
        that archive&#39;s name is used.

        In either case, any existing version is backed up before the
        new one is created, with up to two levels of backups (with &#39;%&#39;
        and &#39;%%&#39; suffixes).
        &#34;&#34;&#34;
        # *** Perhaps this should be called by __del__; or this possibility
        # could be set by a flag on init???

        # If no name given, use the name provided at creation.
        if fname is None:
            if self._fname is None:
                raise ValueError(&#39;Need a file name for saving!&#39;)
            fname = self._fname
        else:
            if not fname.endswith(&#39;.pkl&#39;):
                fname = fname + &#39;.pkl&#39;
        # Gather attributes to store; note new versions supersede old ones.
        attrs = {}
        for name, val in list(self._pulled.items()):
            attrs[name] = val
        # Don&#39;t forget to get any archived values not already accessed.
        if self._archive:
            for name in list(self._archive.keys()):
                if name not in self._pulled:
                    attrs[name] = self._archive[name]
        for name, val in list(self._new.items()):
            attrs[name] = val
        # Backup any existing file, and save the attrs to a new file.
        ofile = safe_open(fname, &#39;b&#39;)
        pkl.dump(attrs, ofile, -1)  # use highest protocol
        ofile.close()

    def contents(self):
        &#34;&#34;&#34;
        List the names of arrays accessible by this store, including
        both previously archived arrays and newly defined arrays.
        &#34;&#34;&#34;
        names = []
        if self._archive:
            names.extend(list(self._archive.keys()))
        names.extend(list(self._new.values()))
        return names



if __name__ == &#39;__main__&#39;:
    from numpy import *

    # Store some arrays.
    print(&#39;Testing ArrayStore:&#39;)
    store = ArrayStore()
    store.a = array([1,2,3])
    store.b = array([[1., 2.], [3., 4.]])
    store.save(&#39;junk&#39;)

    # Read the stored arrays.
    store2 = ArrayStore(&#39;junk&#39;)
    print(&#39;a:&#39;, store2.a)
    print(&#39;b:&#39;, store2.b)
    store2.c = eye(6)
    store2.a = ones(5, float)
    store2.save()
    store2 = ArrayStore(&#39;junk&#39;)
    print(&#39;store2 should have altered a and new c.&#39;)

    # Store a mix of arrays and other pickleable objects.
    print(&#39;\nTesting AttrStore:&#39;)
    store3 = AttrStore(a=array([1,2,3]), c=42)
    store3.b = array([[1., 2.], [3., 4.]])
    store3.d = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
    store3.s = &#39;This is a test&#39;
    store3.save(&#39;junk2&#39;)

    # Read the stored objects.
    store4 = AttrStore(&#39;junk2&#39;)
    print(&#39;a:&#39;, store4.a)
    print(&#39;b:&#39;, store4.b)
    print(&#39;c:&#39;, store4.c)
    print(&#39;d:&#39;, store4.d)
    print(&#39;s:&#39;, store4.s)
    store4.e = eye(6)
    store4.a = ones(5, float)
    store4.save()
    store4 = AttrStore(&#39;junk2&#39;)
    print(&#39;store4 should have altered a and new e.&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="inference.utils.ioutils.backup"><code class="name flex">
<span>def <span class="ident">backup</span></span>(<span>fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Backup any existing file with name fname, up to two levels.
If a
file fname exists, the existing copy is renamed with a '%'appended
to its name.
If such a backup already exists, it is renamed with an
additional '%' appended, overwriting any previous such file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backup(fname):
    &#34;&#34;&#34;
    Backup any existing file with name fname, up to two levels.  If a
    file fname exists, the existing copy is renamed with a &#39;%&#39;appended
    to its name.  If such a backup already exists, it is renamed with an
    additional &#39;%&#39; appended, overwriting any previous such file.
    &#34;&#34;&#34;
    if path.exists(fname):
        bname = fname + &#39;%&#39;
        if path.exists(bname):
            bbname = bname + &#39;%&#39;
            os.rename(bname, bbname)
        os.rename(fname, bname)</code></pre>
</details>
</dd>
<dt id="inference.utils.ioutils.safe_open"><code class="name flex">
<span>def <span class="ident">safe_open</span></span>(<span>fname, binary=False, opener=None, *args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a file by name for writing, backing up an existing version up
to two levels.
If the file exists, the existing copy is renamed with
a '%'appended to its name.
If such a backup already exists, it is
renamed with an additional '%' added, overwriting any previous such
file.
Return the opened file object.</p>
<p>By default, the file is opened with the <code>open</code> built-in, with 'w'
mode.
If <code>opener</code> is specified, it is used to open the file,
passing any additional arguments after the file name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_open(fname, binary=False, opener=None, *args, **kwds):
    &#34;&#34;&#34;
    Open a file by name for writing, backing up an existing version up
    to two levels.  If the file exists, the existing copy is renamed with
    a &#39;%&#39;appended to its name.  If such a backup already exists, it is
    renamed with an additional &#39;%&#39; added, overwriting any previous such
    file.  Return the opened file object.

    By default, the file is opened with the `open` built-in, with &#39;w&#39;
    mode.  If `opener` is specified, it is used to open the file,
    passing any additional arguments after the file name.
    &#34;&#34;&#34;
    backup(fname)
    if opener:
        if args:
            fobj = opener(fname, *args, **kwds)
        else:
            fobj = opener(fname)
    else:
        if binary is True or binary == &#39;b&#39;:
            fobj = open(fname, &#39;wb&#39;)
        else:
            fobj = open(fname, &#39;w&#39;)
    return fobj</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="inference.utils.ioutils.ArrayStore"><code class="flex name class">
<span>class <span class="ident">ArrayStore</span></span>
<span>(</span><span>fname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A container class that provides lazy persistance of array instance
attributes via NumPy's .npz archives.</p>
<p>This is doubly lazy:
arrays are not read into the namespace until
actually requested, and they are not saved to the archive until the
ArrayStore is explicitly saved.</p>
<p>Prepare to load arrays from storage if a file name is provided;
otherwise support saving of arrays assigned as attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayStore(object):
    &#34;&#34;&#34;
    A container class that provides lazy persistance of array instance
    attributes via NumPy&#39;s .npz archives.

    This is doubly lazy:  arrays are not read into the namespace until
    actually requested, and they are not saved to the archive until the
    ArrayStore is explicitly saved.
    &#34;&#34;&#34;

    # *** Is loading really lazy, i.e., does NumPy&#39;s load() read in array data
    # before actual access via dict lookup?

    # TODO:  Perhaps have a __del__ method that saves on deletion?
    # It would have to handle fname=None gracefully.
    # Perhaps an init arg should specify whether to save on deletion.

    # TODO:  Support creating with a name to a non-existing file;
    # subsequent &#34;save()&#34; will use the stored name.

    def __init__(self, fname=None):
        &#34;&#34;&#34;
        Prepare to load arrays from storage if a file name is provided;
        otherwise support saving of arrays assigned as attributes.
        &#34;&#34;&#34;
        # All internal attributes start with &#39;_&#39; to avoid __setattr__
        # array filtering.
        if fname:
            if not fname.endswith(&#39;.npz&#39;):
                fname = fname + &#39;.npz&#39;
                self._npz = load(fname)
        else:
            self._npz = None
        self._fname = fname
        self._archived = {}  # arrays pulled from the archive
        self._new = {}  # arrays to be archived

    def __getattr__(self, name):
        &#34;&#34;&#34;
        Catch references to array attributes that have not yet been
        loaded from the archive.
        &#34;&#34;&#34;
        # This is called only if name is not already in the instance dict.
        if self._npz is None:  # no archive to grab attribute from
            raise AttributeError(name)
        else:  # get value from archive and keep a reference to it
            try:
                value = self._npz[name]
                # Set the attribute directly so __setattr__ won&#39;t add it
                # to self.new.
                object.__setattr__(self, name, value)
                self._archived[name] = value
                return value
            except:
                raise AttributeError(name)

    def __setattr__(self, name, value):
        &#34;&#34;&#34;
        Catch assignments to new attributes, marking them for saving when
        the store is next saved.

        Names starting with &#39;_&#39; have their corresponding attributes set
        without marking; such names are intended for internal use only,
        to keep track of the state of the store.
        &#34;&#34;&#34;
        # *** Should this prevent over-writing existing names, either
        # directly assigned or yet to be loaded from the archive?
        # Right now we allow reassignments; saving will save the
        # reassigned value.
        if name.startswith(&#39;_&#39;):
            object.__setattr__(self, name, value)
        elif isinstance(value, ndarray):
            self._new[name] = value
            object.__setattr__(self, name, value)
        else:
            raise ValueError(&#39;Only ndarray objects may be stored!&#39;)

    def save(self, fname=None):
        &#34;&#34;&#34;
        Save array attributes to a NumPy .npz archive.  If a name is
        provided, it is used (adding &#39;.npz&#39; if needed); otherwise it is
        presumed this store was created from an existing archive, and
        that archive&#39;s name is used.

        In either case, any existing version is backed up before the
        new one is created, with up to two levels of backups (with &#39;%&#39;
        and &#39;%%&#39; suffixes).
        &#34;&#34;&#34;
        # *** Perhaps this should be called by __del__; or this possibility
        # could be set by a flag on init???

        # If no name given, use the name provided at creation.
        if fname is None:
            if self._fname is None:
                raise ValueError(&#39;Need a file name for saving!&#39;)
            fname = self._fname
        else:
            if not fname.endswith(&#39;.npz&#39;):
                fname = fname + &#39;.npz&#39;
        # Gather arrays to store; note new versions supersede old ones.
        arrays = {}
        for name, val in list(self._archived.items()):
            arrays[name] = val
        # Don&#39;t forget to get any archived values not already accessed.
        if self._npz:
            for name in self._npz.files:
                if name not in self._archived:
                    arrays[name] = self._npz[name]
        for name, val in list(self._new.items()):
            arrays[name] = val
        # Backup any existing file, and save the arrays to a new file.
        backup(fname)
        savez(fname, **arrays)

    def contents(self):
        &#34;&#34;&#34;
        List the names of arrays accessible by this store, including
        both previously archived arrays and newly defined arrays.
        &#34;&#34;&#34;
        names = []
        if self._npz:
            names.extend(self._npz.files)  # archive file names will be array names
        names.extend(list(self._new.values()))
        return names</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="inference.utils.ioutils.ArrayStore.contents"><code class="name flex">
<span>def <span class="ident">contents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List the names of arrays accessible by this store, including
both previously archived arrays and newly defined arrays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contents(self):
    &#34;&#34;&#34;
    List the names of arrays accessible by this store, including
    both previously archived arrays and newly defined arrays.
    &#34;&#34;&#34;
    names = []
    if self._npz:
        names.extend(self._npz.files)  # archive file names will be array names
    names.extend(list(self._new.values()))
    return names</code></pre>
</details>
</dd>
<dt id="inference.utils.ioutils.ArrayStore.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, fname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save array attributes to a NumPy .npz archive.
If a name is
provided, it is used (adding '.npz' if needed); otherwise it is
presumed this store was created from an existing archive, and
that archive's name is used.</p>
<p>In either case, any existing version is backed up before the
new one is created, with up to two levels of backups (with '%'
and '%%' suffixes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, fname=None):
    &#34;&#34;&#34;
    Save array attributes to a NumPy .npz archive.  If a name is
    provided, it is used (adding &#39;.npz&#39; if needed); otherwise it is
    presumed this store was created from an existing archive, and
    that archive&#39;s name is used.

    In either case, any existing version is backed up before the
    new one is created, with up to two levels of backups (with &#39;%&#39;
    and &#39;%%&#39; suffixes).
    &#34;&#34;&#34;
    # *** Perhaps this should be called by __del__; or this possibility
    # could be set by a flag on init???

    # If no name given, use the name provided at creation.
    if fname is None:
        if self._fname is None:
            raise ValueError(&#39;Need a file name for saving!&#39;)
        fname = self._fname
    else:
        if not fname.endswith(&#39;.npz&#39;):
            fname = fname + &#39;.npz&#39;
    # Gather arrays to store; note new versions supersede old ones.
    arrays = {}
    for name, val in list(self._archived.items()):
        arrays[name] = val
    # Don&#39;t forget to get any archived values not already accessed.
    if self._npz:
        for name in self._npz.files:
            if name not in self._archived:
                arrays[name] = self._npz[name]
    for name, val in list(self._new.items()):
        arrays[name] = val
    # Backup any existing file, and save the arrays to a new file.
    backup(fname)
    savez(fname, **arrays)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="inference.utils.ioutils.AttrStore"><code class="flex name class">
<span>class <span class="ident">AttrStore</span></span>
<span>(</span><span>fname=None, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>A container class that provides lazy persistance of instance attributes
as a Python pickle.</p>
<p>This is doubly lazy:
attributes are not placed in the namespace until
actually requested, and they are not saved to the archive until the
AttrStore is explicitly saved.</p>
<p>If only NumPy arrays are to be stored, ArrayStore may be more efficient.</p>
<p>Prepare to load attributes from storage if a file name is provided;
otherwise support saving of arrays assigned as attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttrStore(object):
    &#34;&#34;&#34;
    A container class that provides lazy persistance of instance attributes
    as a Python pickle.

    This is doubly lazy:  attributes are not placed in the namespace until
    actually requested, and they are not saved to the archive until the
    AttrStore is explicitly saved.
    
    If only NumPy arrays are to be stored, ArrayStore may be more efficient.
    &#34;&#34;&#34;

    # *** Is there any virtue to laziness in loading the namespace, since
    # we aren&#39;t unpacking a NumPy npz file archive?

    # TODO:  Perhaps have a __del__ method that saves on deletion?
    # It would have to handle fname=None gracefully.
    # Perhaps an init arg should specify whether to save on deletion.

    # TODO:  Support creating with a name to a non-existing file;
    # subsequent &#34;save()&#34; will use the stored name.
    
    # TODO:  Add kwd args to init for setting attributes to store.

    def __init__(self, fname=None, **kwds):
        &#34;&#34;&#34;
        Prepare to load attributes from storage if a file name is provided;
        otherwise support saving of arrays assigned as attributes.
        &#34;&#34;&#34;
        # All internal attributes start with &#39;_&#39; to avoid __setattr__
        # array filtering.
        if fname:
            if not fname.endswith(&#39;.pkl&#39;):
                fname = fname + &#39;.pkl&#39;
                ifile = open(fname, &#39;rb&#39;)
                self._archive = pkl.load(ifile)
                ifile.close()
        else:
            self._archive = None
        self._fname = fname
        self._pulled = {}  # attributes pulled from the archive
        self._new = {}  # attributes to be archived
        if kwds:
            for key, value in list(kwds.items()):
                setattr(self, key, value)

    def __getattr__(self, name):
        &#34;&#34;&#34;
        Catch references to attributes that have not yet been loaded from
        the store.
        &#34;&#34;&#34;
        # This is called only if name is not already in the instance dict.
        if self._archive is None:  # no archive to grab attribute from
            raise AttributeError(name)
        else:  # get value from archive and keep a reference to it
            try:
                value = self._archive[name]
                # Set the attribute directly so __setattr__ won&#39;t add it
                # to self.new.
                object.__setattr__(self, name, value)
                self._pulled[name] = value
                return value
            except:
                raise AttributeError(name)

    def __setattr__(self, name, value):
        &#34;&#34;&#34;
        Catch assignments to new attributes, marking them for saving when
        the store is next saved.

        Names starting with &#39;_&#39; have their corresponding attributes set
        without marking; such names are intended for internal use only,
        to keep track of the state of the store.
        &#34;&#34;&#34;
        # *** Should this prevent over-writing existing names, either
        # directly assigned or yet to be loaded from the archive?
        # Right now we allow reassignments; saving will save the
        # reassigned value.
        if name.startswith(&#39;_&#39;):
            object.__setattr__(self, name, value)
        else:
            self._new[name] = value
            object.__setattr__(self, name, value)

    def save(self, fname=None):
        &#34;&#34;&#34;
        Save attributes to a high-protocol pickle.  If a name is
        provided, it is used (adding &#39;.pkl&#39; if needed); otherwise it is
        presumed this store was created from an existing archive, and
        that archive&#39;s name is used.

        In either case, any existing version is backed up before the
        new one is created, with up to two levels of backups (with &#39;%&#39;
        and &#39;%%&#39; suffixes).
        &#34;&#34;&#34;
        # *** Perhaps this should be called by __del__; or this possibility
        # could be set by a flag on init???

        # If no name given, use the name provided at creation.
        if fname is None:
            if self._fname is None:
                raise ValueError(&#39;Need a file name for saving!&#39;)
            fname = self._fname
        else:
            if not fname.endswith(&#39;.pkl&#39;):
                fname = fname + &#39;.pkl&#39;
        # Gather attributes to store; note new versions supersede old ones.
        attrs = {}
        for name, val in list(self._pulled.items()):
            attrs[name] = val
        # Don&#39;t forget to get any archived values not already accessed.
        if self._archive:
            for name in list(self._archive.keys()):
                if name not in self._pulled:
                    attrs[name] = self._archive[name]
        for name, val in list(self._new.items()):
            attrs[name] = val
        # Backup any existing file, and save the attrs to a new file.
        ofile = safe_open(fname, &#39;b&#39;)
        pkl.dump(attrs, ofile, -1)  # use highest protocol
        ofile.close()

    def contents(self):
        &#34;&#34;&#34;
        List the names of arrays accessible by this store, including
        both previously archived arrays and newly defined arrays.
        &#34;&#34;&#34;
        names = []
        if self._archive:
            names.extend(list(self._archive.keys()))
        names.extend(list(self._new.values()))
        return names</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="inference.utils.ioutils.AttrStore.contents"><code class="name flex">
<span>def <span class="ident">contents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List the names of arrays accessible by this store, including
both previously archived arrays and newly defined arrays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contents(self):
    &#34;&#34;&#34;
    List the names of arrays accessible by this store, including
    both previously archived arrays and newly defined arrays.
    &#34;&#34;&#34;
    names = []
    if self._archive:
        names.extend(list(self._archive.keys()))
    names.extend(list(self._new.values()))
    return names</code></pre>
</details>
</dd>
<dt id="inference.utils.ioutils.AttrStore.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, fname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save attributes to a high-protocol pickle.
If a name is
provided, it is used (adding '.pkl' if needed); otherwise it is
presumed this store was created from an existing archive, and
that archive's name is used.</p>
<p>In either case, any existing version is backed up before the
new one is created, with up to two levels of backups (with '%'
and '%%' suffixes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, fname=None):
    &#34;&#34;&#34;
    Save attributes to a high-protocol pickle.  If a name is
    provided, it is used (adding &#39;.pkl&#39; if needed); otherwise it is
    presumed this store was created from an existing archive, and
    that archive&#39;s name is used.

    In either case, any existing version is backed up before the
    new one is created, with up to two levels of backups (with &#39;%&#39;
    and &#39;%%&#39; suffixes).
    &#34;&#34;&#34;
    # *** Perhaps this should be called by __del__; or this possibility
    # could be set by a flag on init???

    # If no name given, use the name provided at creation.
    if fname is None:
        if self._fname is None:
            raise ValueError(&#39;Need a file name for saving!&#39;)
        fname = self._fname
    else:
        if not fname.endswith(&#39;.pkl&#39;):
            fname = fname + &#39;.pkl&#39;
    # Gather attributes to store; note new versions supersede old ones.
    attrs = {}
    for name, val in list(self._pulled.items()):
        attrs[name] = val
    # Don&#39;t forget to get any archived values not already accessed.
    if self._archive:
        for name in list(self._archive.keys()):
            if name not in self._pulled:
                attrs[name] = self._archive[name]
    for name, val in list(self._new.items()):
        attrs[name] = val
    # Backup any existing file, and save the attrs to a new file.
    ofile = safe_open(fname, &#39;b&#39;)
    pkl.dump(attrs, ofile, -1)  # use highest protocol
    ofile.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="inference.utils" href="index.html">inference.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="inference.utils.ioutils.backup" href="#inference.utils.ioutils.backup">backup</a></code></li>
<li><code><a title="inference.utils.ioutils.safe_open" href="#inference.utils.ioutils.safe_open">safe_open</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="inference.utils.ioutils.ArrayStore" href="#inference.utils.ioutils.ArrayStore">ArrayStore</a></code></h4>
<ul class="">
<li><code><a title="inference.utils.ioutils.ArrayStore.contents" href="#inference.utils.ioutils.ArrayStore.contents">contents</a></code></li>
<li><code><a title="inference.utils.ioutils.ArrayStore.save" href="#inference.utils.ioutils.ArrayStore.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="inference.utils.ioutils.AttrStore" href="#inference.utils.ioutils.AttrStore">AttrStore</a></code></h4>
<ul class="">
<li><code><a title="inference.utils.ioutils.AttrStore.contents" href="#inference.utils.ioutils.AttrStore.contents">contents</a></code></li>
<li><code><a title="inference.utils.ioutils.AttrStore.save" href="#inference.utils.ioutils.AttrStore.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>