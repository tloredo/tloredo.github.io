<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>inference.grid.grid1d API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>inference.grid.grid1d</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Created:  21 Apr 2000 by Tom Loredo
# Adapted from RefinedGrid1D to InferenceGrid1: 15 Mar 2001
# Last mod: 15 Mar 2001

from numpy import sqrt, log, floor, ceil, pi
from numpy import fromfunction, array, zeros, sum, exp, clip, shape
# from types import TupleType, ListType

from .. import utils

__all__ = [&#39;Grid1D&#39;, &#39;Lin&#39;, &#39;Log&#39;]

Lin = &#34;linear&#34;
Log = &#34;log&#34;
rt2pi = sqrt(2*pi)
smallExp = -725.


def IsPeak(y):
    &#34;&#34;&#34;Return true if the triplet of y values represents a local maximum.&#34;&#34;&#34;

    return (y[0] &lt; y[1] &gt; y[2]) or (y[0] &lt; y[1] == y[2])


def PeakParams(x, y):
    &#34;&#34;&#34;Given log f(x) at three points, estimate the parameters of a 
    Gaussian function through those points, (A, mean, sig).

    This generalizes the regular grid algorithm of H. J. Sanchez,
    Comp. in Phys., Jul/Aug 1991, 407.&#34;&#34;&#34;

    w = x[2]-x[0]
    alpha = (x[1]-x[0]) / w
    alpha2 = alpha**2
    fac = 1. - 2.*alpha2
    a12 = y[0] - y[1]
    C = alpha2/fac + a12/(a12-y[1]+y[2])
    d = C*w*fac**2 / (2.*alpha*(1.-alpha) + C*(2.-4.*alpha)*fac)
    mean = x[0] + d
    alpha2 = w*alpha
    sig = alpha2*(0.5*alpha2 - d) / a12
    logA = y[1] + 0.5*(x[1]-mean)**2/sig
    sig = sqrt(sig)
    return (logA, mean, sig)


################################################################################
class LabeledMaxList:
    &#34;&#34;&#34;Maintain a sorted list of a fixed number of maximum values of
    a quantity, along with labels of the maxima.&#34;&#34;&#34;

    def __init__(self, nmax=None, dynrange=None):
        &#34;&#34;&#34;Sets the length of the list of labeled maxima.&#34;&#34;&#34;
        self.nmax = nmax
        if dynrange is None:
            self.dynrange = None
        else:
            self.dynrange = log(dynrange)
        self.list = []

    def __len__(self):
        return len(self.list)

    def __getitem__(self, n):
        return self.list[n]

    def __setitem__(self, n, val):
        self.list[n] = val

    def __delitem__(self, n, val):
        del self.list[n]

    def __repr__(self):
        return repr(self.list)

    def __str__(self):
        return str(self.list)

    def update(self, q, label):
        &#34;&#34;&#34;Update the list of maxima by considering a new value of the
        sorted quantity, q, whose label tuple is given by label.&#34;&#34;&#34;

        # Don&#39;t waste time if q is lower than the last element of a full list.
        hi = len(self.list)
        if (hi == self.nmax) and (q &lt;= self.list[-1][0]):
            return

        # We&#39;ll do this by bisection, as in the bisect.py library module.
        lo = 0
        while lo &lt; hi:
            mid = (lo+hi)//2
            if q &gt; self.list[mid][0]:
                hi = mid
            else:
                lo = mid+1
        self.list.insert(lo, (q, label))
        if self.nmax is not None:
            if len(self.list) &gt; self.nmax:
                del self.list[self.nmax]

        # Check the dynamic range spanned by list members if necessary.
        if self.dynrange:
            top = self.list[0][0]
            i = lo        # We must start at lo in case we inserted at the end.
            while i &lt; len(self.list):
                if top - self.list[i][0] &gt; self.dynrange:
                    del self.list[i]
                else:
                    i = i+1

    def limitRange(self, dynrange):
        &#34;&#34;&#34;Ensure that elements of the current list span a limited dynamic
        range.  This presumes the elements are the *logarithms* of the
        quantity of interest.&#34;&#34;&#34;

        logrange = log(dynrange)
        top = self.list[0][0]
        i = 1
        while i &lt; len(self.list):
            if top - self.list[i][0] &gt; logrange:
                del self.list[i]
            else:
                i = i+1


################################################################################
class BasicInterval:
    &#34;&#34;&#34;A basic, positively-directed (closed) interval of equispaced samples.&#34;&#34;&#34;

    def __init__(self, lo, hi, n, stype=&#34;linear&#34;):
        &#34;&#34;&#34;Define the interval and sample density.
        This assumes the direction has been verified in the calling code.&#34;&#34;&#34;

        self.lo = lo
        self.hi = hi
        if (n &lt;= 1):
            raise ValueError(&#34;Need n &gt; 1!&#34;)
        self.n = n
        if stype == &#34;lin&#34; or stype == &#34;linear&#34;:
            self.step = (hi-lo) / (n-1.)
            self.fac = None
            self.isLin = 1
        elif stype == &#34;log&#34; or stype == &#34;logarithmic&#34;:
            if lo*hi &lt;= 0.:
                raise ValueError(&#34;Bad bounds for log interval!&#34;)
            self.step = log(hi/lo) / (n-1.)
            self.fac = exp(self.step)
            self.isLin = 0
        else:
            raise ValueError(&#34;Interval stype must be Lin or Log!&#34;)

    def __str__(self):
        if self.isLin:
            stype = Lin
        else:
            stype = Log
        return str((self.lo, self.hi, self.n, stype, self.step))

    def locate(self, x):
        &#34;&#34;&#34;Locate x in the interval, returning the subinterval
        number and endpoints (i, l, h).  This assumes x is
        in fact in the interval.  If x=hi, then i=n, and l=h=hi.&#34;&#34;&#34;

        if self.isLin:
            i = int(floor((x-self.lo)/self.step))
            l = self.lo + i*self.step
            h = l + self.step
        else:
            i = int(floor(log(x/self.lo)/self.step))
            l = self.lo * exp(i*self.step)
            h = l * self.fac
        if (i == self.n-1):
            h = l
        return (i, l, h)

    def resample(self, n):
        &#34;&#34;&#34;Change the # of samples in the interval.&#34;&#34;&#34;

        self.n = n
        if self.isLin:
            self.step = (self.hi-self.lo) / (n-1.)
        else:
            self.step = log(self.hi/self.lo) / (n-1.)


################################################################################
class RefinedIntervalList1D:
    &#34;&#34;&#34;Maintain a list of continguous 1-d sampled intervals, bounded by the
    initial interval.  Ensure that all subintervals are sampled more
    densely than the base interval.&#34;&#34;&#34;

    def __init__(self, lo, hi, n, stype=&#34;linear&#34;):
        &#34;&#34;&#34;Define the overall interval and base sample density.&#34;&#34;&#34;

        # Save some defining info.  Note that the internal representation
        # is always a positively directed interval, and if the list is of
        # log stype, the log boundaries are stored.
        if n &lt;= 1:
            raise ValueError(&#34;Number of samples must be &gt;1!&#34;)
        if lo == hi:
            raise ValueError(&#34;Null base interval!&#34;)
        elif lo &lt; hi:
            self.isPos = 1
            self.lo = lo
            self.hi = hi
        else:
            self.isPos = 0
            self.lo = hi
            self.hi = lo
        stype = stype.lower()
        if stype == &#34;lin&#34; or stype == &#34;linear&#34;:
            self.isLin = 1
        elif stype == &#34;log&#34; or stype == &#34;logarithmic&#34;:
            self.isLin = 0
            if lo*hi &lt;= 0.:
                raise ValueError(&#34;Zero boundary for log interval!&#34;)
        else:
            raise ValueError(&#34;Interval stype must be Lin or Log!&#34;)
        self.base = BasicInterval(self.lo, self.hi, n, stype=stype)

        # Initialize the list with the base interval.
        self.ilist = [self.base]
        self.nint = 1
        self.npts = n        # This is correct only at the end of updates/merges.
        self.cumpts = [n]    # Ditto for this.

    def __str__(self):

        if self.isPos:
            s = &#34;Positively oriented interval list: \n&#34;
        else:
            s = &#34;Reverse-sense interval list: \n&#34;
        s += &#34;[\n&#34;
        for i in self.ilist:
            s = s + str(i) + &#34;\n&#34;
        s += &#34;]\n&#34;
        return s

    def __getitem__(self, n):

        return self.ilist[n]

    def _del(self, i):
        &#34;&#34;&#34;Delete an interval into the interval list.
        This is private because it corrupts adjacency and point count.&#34;&#34;&#34;

        del self.ilist[i]
        self.nint = self.nint - 1

    def _insert(self, i, intvl):
        &#34;&#34;&#34;Insert an interval into the interval list.
        This is private because it can corrupt adjacency and point count.&#34;&#34;&#34;

        self.ilist.insert(i, intvl)
        self.nint = self.nint + 1

#*** There could be an inconsistency from ignoring isPos...
    def _stepSize(self, lo, hi, n):
        &#34;&#34;&#34;Calculate the step size for a candidate inserted interval.&#34;&#34;&#34;

        if self.isLin:
            return (hi-lo) / (n-1.)
        else:
            return log(hi/lo) / (n-1.)

#*** There could be an inconsistency from ignoring isPos...
    def _numPts(self, lo, hi, step):
        &#34;&#34;&#34;Calculate the step size for a candidate inserted interval.&#34;&#34;&#34;

        if self.isLin:
            return int(ceil((hi-lo)/step)) + 1
        else:
            return int(ceil(log(hi/lo)/step)) + 1

    def update(self, lo, hi, n):
        &#34;&#34;&#34;Update the interval list to include a new interval.&#34;&#34;&#34;

        # First, make sure we are in the base interval.  Truncate if bigger;
        # complain if it doesn&#39;t overlap at all.
        if self.isPos:
            lo = max(lo, self.lo)
            hi = min(hi, self.hi)
        else:
            lo = max(hi, self.lo)
            hi = min(lo, self.hi)
        if hi &lt;= lo:
            raise ValueError(&#34;Interval does not overlap base interval!&#34;)

        # Identify which intervals include the new boundaries.
        for i in range(self.nint):
            if (self.ilist[i].lo &lt;= lo and self.ilist[i].hi &gt; lo):
                nlo = i
                int_lo = self.ilist[i]
                break
        for i in range(self.nint):
            if (self.ilist[i].lo &lt; hi and self.ilist[i].hi &gt;= hi):
                nhi = i
                int_hi = self.ilist[i]
                break

        # Now expand the new interval to abutt grid pts in existing intervals,
        # updating the # of points to maintain the density, unless the new
        # interval is unresolved.  In that case, the input is not trustworthy
        # and maintaining density will add too many points.  Just add n points.
        step = self._stepSize(lo, hi, n)
        lo_int = int_lo.locate(lo)
        lo = lo_int[1]
        hi_int = int_hi.locate(hi)  # returns (i, lo, hi) of grid point pair
        if hi != hi_int[1]:  # if not lo, it&#39;s within the grid space; set to hi
            hi = hi_int[2]
        # Test if resolved.  Use lo_int rather than hi_int, because if
        # hi happens to hit an endpoint, hi_int&#39;s lo == its hi.
        if 5*step &gt; (lo_int[2]-lo_int[1]):  # resolved
            n = self._numPts(lo, hi, step)
        step = self._stepSize(lo, hi, n)

        # If the new intvl is entirely in an existing one, we have to insert it,
        # unless it undersamples the interval.  Be careful of it exactly matching
        # a boundary, in which case fewer inserts are needed.
        if nlo == nhi:
            if step &gt;= int_lo.step:  # undersampled; ignore the new interval
                return
            self._del(nlo)
            if lo &gt; int_lo.lo:
                m = self._numPts(int_lo.lo, lo, int_lo.step)
                self._insert(nlo, BasicInterval(int_lo.lo, lo, m))
                nlo = nlo + 1
            self._insert(nlo, BasicInterval(lo, hi, n))
            if int_lo.hi &gt; hi:
                m = self._numPts(hi, int_lo.hi, int_lo.step)
                self._insert(nlo+1, BasicInterval(hi, int_lo.hi, m))
            self.merge()
            return

        # Otherwise, we have to break up the intervals containing the boundaries,
        # and possibly resample intervals completely covered by the new one.
        if (step &lt; int_lo.step):
            self._del(nlo)
            if lo &gt; int_lo.lo:
                m = self._numPts(int_lo.lo, lo, int_lo.step)
                self._insert(nlo, BasicInterval(int_lo.lo, lo, m))
                nlo = nlo + 1
                nhi = nhi + 1        # Shift nhi since we&#39;re adding an intvl.
            m = self._numPts(lo, int_lo.hi, step)
            self._insert(nlo, BasicInterval(lo, int_lo.hi, m))
            nlo = nlo + 1
        if step &lt; int_hi.step:
            self._del(nhi)
            m = self._numPts(int_hi.lo, hi, step)
            self._insert(nhi, BasicInterval(int_hi.lo, hi, m))
            if int_hi.hi &gt; hi:
                m = self._numPts(hi, int_hi.hi, int_hi.step)
                self._insert(nhi+1, BasicInterval(hi, int_hi.hi, m))
                # We needn&#39;t update nhi here since range won&#39;t include it.
        for i in range(nlo, nhi):
            if self.ilist[i].step &gt; step:
                n = self._numPts(self.ilist[i].lo, self.ilist[i].hi,
                                 step)
                self.ilist[i].resample(n)
        self.merge()

    def merge(self):
        &#34;&#34;&#34;Merge adjacent intervals with a common step size to make
        the interval list as small as possible.
        This also makes a correct point count (not counting overlapping
        points at boundaries).&#34;&#34;&#34;

        i = 0
        self.npts = self.ilist[0].n - 1
        self.cumpts = [self.npts]
        while 1:
            if self.nint &lt; i+2:        # Return if there is no next intvl.
                self.npts = self.npts + 1
                self.cumpts[-1] = self.npts
                return
            self.npts = self.npts + self.ilist[i+1].n - 1
            self.cumpts.append(self.npts)
            if self.ilist[i].step == self.ilist[i+1].step:    # Merge.
                lo = self.ilist[i].lo
                hi = self.ilist[i+1].hi
                n = self.ilist[i].n + self.ilist[i+1].n - 1
                self._del(i)
                self._del(i)
                self._insert(i, BasicInterval(lo, hi, n))
                self.cumpts[i] = self.cumpts[i+1]
                del self.cumpts[-1]
            else:
                i = i + 1

    def nonbase(self):
        &#34;&#34;&#34;Return a list of all non-base (i.e., refined) intervals.&#34;&#34;&#34;

        l = []
        for intvl in self.ilist:
            if intvl.step != self.base.step:
                l.append(intvl)
        return l

    def locate(self, x):
        &#34;&#34;&#34;Return the interval containing x.&#34;&#34;&#34;

        # Make sure x is in range.
        if x &lt; self.lo or x &gt; self.hi:
            raise ValueError(&#34;x out of range!&#34;)

        # We&#39;ll treat the intervals as [), except the last which is [].
        if x == self.hi:
            return self.ilist[-1]

        # Use bisection.
        lo = 0
        hi = self.nint
        mid = (lo+hi)//2
        while 1:
            if self.ilist[mid].lo &lt;= x &lt; self.ilist[mid].hi:
                break
            elif x &lt; self.ilist[mid].lo:
                hi = mid
            else:
                lo = mid
            mid = (lo+hi)//2
        return self.ilist[mid]

    def nlocate(self, n):
        &#34;&#34;&#34;Return the interval containing pt number n (0-based);
        include the intvl number and the location of n in the intvl.&#34;&#34;&#34;

        # Make sure n is in range.
        if n &lt; 0 or n &gt; self.npts-1:
            raise ValueError(&#34;n out of range!&#34;)

        # We&#39;ll treat the intervals as [), except the last which is [].
        if n == self.npts-1:
            return (self.nint-1, self.ilist[-1].n-1, self.ilist[-1])

        # Use bisection.
        lo = 0
        hi = self.nint
        while lo &lt; hi:
            mid = (lo+hi)//2
            if n+1 &gt; self.cumpts[mid]:
                lo = mid + 1
            else:
                hi = mid
        if lo == 0:
            indx = n
        else:
            indx = n - self.cumpts[lo-1]
        return (lo, indx, self.ilist[lo])


################################################################################
class BasicGrid1D:
    &#34;&#34;&#34;Create a 1-d linear- or log-spaced grid with automated evaluation of a 
    function and optional bookkeeping of local maxima.

    For calculation of maxima properties and normalization, function values
    are treated as the logs of the function to be integrated.&#34;&#34;&#34;

    def __init__(self, lo, hi, n, stype=&#34;linear&#34;, lml=None, rank=&#39;peak&#39;):
        &#34;&#34;&#34;Define the grid abscissa.&#34;&#34;&#34;

        # Copy basic defining data and check for possible illegal values.
        self.lo = lo
        self.hi = hi
        if n &lt;= 1:
            raise ValueError(&#34;Number of points must be &gt;1!&#34;)
        self.n = n
        stype = stype.lower()
        if stype == &#34;lin&#34; or stype == &#34;linear&#34;:
            self.isLin = 1
        elif stype == &#34;log&#34; or stype == &#34;logarithmic&#34;:
            self.isLin = 0
            if lo*hi &lt;= 0.:
                raise ValueError(&#34;Bad boundaries for log grid!&#34;)
        else:
            raise ValueError(&#34;Grid stype must be Lin or Log!&#34;)
        self.lml = lml
        self.rank = rank
        if rank.lower() == &#39;peak&#39;:
            self.rank_peak = True
        elif rank.lower() == &#39;area&#39;:
            self.rank_peak = False
        else:
            raise ValueError(&#39;rank should be &#34;peak&#34; or &#34;area&#34;!&#39;)
        self.valSeq = None

        # Find the appropriate step size.
        if self.isLin:
            self.step = (hi-lo)/(n-1.)
        else:
            self.step = log(hi/lo)/(n-1.)

        # Initialize abscissas and ordinates to None.
        self.absc = None
        self.vals = None

    def __str__(self):

        s = &#39;[\n&#39;
        for i in range(self.n):
            s = s + str(self.point(i)) + &#39;\n&#39;
        s = s + &#39;]\n&#39;
        return s

    def stepfunc(self, func, select=None, notify=None):
        &#34;&#34;&#34;Gather function values by applying func step by step through the grid.
        Note that we don&#39;t store the abscissas here to save space.
        If the function returns tuples, select picks the element to monitor
        in the list of maxima.
        The notify parameter allows monitoring of progress.&#34;&#34;&#34;

        x1, x2 = None, None
        for i in range(self.n):
            if i == self.n-1:  # Avoid roundoff error at the endpoint.
                x = self.hi
            if self.isLin:
                x = self.lo + i*self.step
            else:
                x = self.lo * exp(i*self.step)

        # First time thru, check whether func returns a sequence and create storage
        # appropriately.
            if i == 0:
                f = func(x)
                if type(f) is tuple or type(f) is list:
                    if select is None:
                        raise ValueError(&#34;must set select!&#34;)
                    self.valSeq = len(f)
                    self.vals = zeros((self.n, self.valSeq), float)
                else:
                    self.vals = zeros((self.n), float)
                self.vals[i] = f
            else:
                self.vals[i] = func(x)

            if notify:
                if i % notify == 0:
                    print(i, x, self.vals[i])

        # Here is the check for a local maximum, with special treatment for
        # possible &#34;half peaks&#34; at the ends.  These have fudged params
        # from a linear fit to 2 pts to find dx causing the log to drop 1/2.
#*** check the endpt trtmt.
            if self.lml is not None and i &gt; 1:
                if self.valSeq:
                    y3 = self.vals[i-2:i+1, select]
                else:
                    y3 = self.vals[i-2:i+1]
                if IsPeak(y3):
                    logA, mean, sig = PeakParams((x1, x2, x), y3)
                    area = logA + log(sig*rt2pi)
                    if self.rank_peak:
                        msr = logA
                    else:
                        msr = area
                    self.lml.update(msr, (i-1, logA, mean, sig))
                if i == 2 and (y3[0] &gt; y3[1]):  # half peak at left?
                    sig = -0.5*(x2-x1)/(y3[1]-y3[0])
                    logA, mean = y3[0], x1
                    area = logA + log(0.5*sig*rt2pi)
                    if self.rank_peak:
                        msr = logA
                    else:
                        msr = area
                    self.lml.update(msr, (i-2, logA, mean, sig))
                if i == (self.n-1) and (y3[1] &lt; y3[2]):  # half peak at right?
                    sig = 0.5*(x-x2)/(y3[2]-y3[1])
                    logA, mean = y3[2], x
                    area = logA + log(0.5*sig*rt2pi)
                    if self.rank_peak:
                        msr = logA
                    else:
                        msr = area
                    self.lml.update(msr, (i, logA, mean, sig))
            x1, x2 = x2, x

#*** test treatment of endpoints, which was just copied from above
    def vecfunc(self, func, select=None):
        &#34;&#34;&#34;Gather function values by applying func to a vector of grid abscissas.&#34;&#34;&#34;

        # First evaluate func on a vector of abscissa values.
        if self.isLin:
            self.absc = self.lo + self.step*fromfunction(lambda i: i, [self.n])
        else:
            self.absc = self.lo * exp(self.step*fromfunction(lambda i: i, [self.n]))
        self.absc[-1] = self.hi  # avoid roundoff error at endpoint
        self.vals = func(self.absc)

        # Note whether or not the values are sequences.
        if len(shape(self.vals)) == 2:
            self.valSeq = shape(self.vals)[1]
        else:
            self.valSeq = None

        # Now look for local maxima, with special treatment for
        # possible &#34;half peaks&#34; at the ends.
        if self.lml:
            for i in range(2,self.n):
                if self.valSeq:
                    y3 = self.vals[i-2:i+1, select]
                else:
                    y3 = self.vals[i-2:i+1]
                x3 = self.absc[i-2:i+1]
                if IsPeak(y3):
                    logA, mean, sig = PeakParams(x3, y3)
                    area = logA + log(sig*rt2pi)
                    if self.rank_peak:
                        msr = logA
                    else:
                        msr = area
                    self.lml.update(msr, (i-1, logA, mean, sig))
                if i == 2 and (y3[0] &gt; y3[1]):
                    #A, mean, sig = PeakParams(self.absc[i-2:i+1], y3)
                    #area = 0.5*A*sig*rt2pi
                    #self.lml.update(area, (i-2, A, mean, sig))
                    sig = -0.5*(x3[1]-x3[0])/(y3[1]-y3[0])
                    logA, mean = y3[0], x3[0]
                    area = logA + log(0.5*sig*rt2pi)
                    if self.rank_peak:
                        msr = logA
                    else:
                        msr = area
                    self.lml.update(msr, (i-2, logA, mean, sig))
                if i == (self.n-1) and (y3[1] &lt; y3[2]):
                    #A, mean, sig = PeakParams(self.absc[i-2:i+1], y3)
                    #area = 0.5*A*sig*rt2pi
                    #self.lml.update(area, (i, A, mean, sig))
                    sig = 0.5*(x3[2]-x3[1])/(y3[2]-y3[1])
                    logA, mean = y3[2], x3[2]
                    area = logA + log(0.5*sig*rt2pi)
                    if self.rank_peak:
                        msr = logA
                    else:
                        msr = area
                    self.lml.update(msr, (i, logA, mean, sig))

    def point(self, i):
        &#34;&#34;&#34;Return the abscissa, width, and value associated with point i.
        The width is the size of the step to the next point, and is
        suitable for trapezoid rule quadrature; it vanishes for the
        right endpoint.&#34;&#34;&#34;

        # Make sure i is legal.
        if i &lt; 0 or i &gt;= self.n:
            raise ValueError(&#34;Illegal index!&#34;)

        # Get abscissa value, using a stored value if available.  If the ordinates
        # have been calculated, get the ordinate; otherwise use None.
        if (self.absc is None):
            if self.isLin:
                x = self.lo + i*self.step
            else:
                x = self.lo * exp(i*self.step)
        else:
            x = self.absc[i]
        if self.vals is None:
            v = None
        else:
            v = self.vals[i]

        # Get the size of the step to the next point (0 for last point!).
        if i == self.n-1:
            w = 0.
        else:
            if self.isLin:
                w = self.step
            else:
                w = x * (exp(self.step)-1.)

        return (x, w, v)

    def trapzd(self, select=None):
        &#34;&#34;&#34;Return the trapezoid rule quadrature of the values on the grid.&#34;&#34;&#34;

        # An empty grid gives an error!
        if (self.vals is None):
            raise RuntimeError(&#34;grid values not yet set!&#34;)

        # Pick out the values to use if we have a grid of tuples.
        if self.valSeq:
            if select is None:
                raise ValueError(&#34;must set select!&#34;)
            vals = self.vals[:, select]
        else:
            if select is not None:
                raise ValueError(&#34;Grid function is a scalar!&#34;)
            vals = self.vals

        # The linear case can use array math.
        if self.isLin:
            return self.step*(sum(vals) - 0.5*(vals[0]+vals[-1]))

        # The log case can either step thru the grid to save space, or
        # make an array of widths to save time.  We do the latter here.
        w = self.absc
        if w is None:
            w = self.lo * exp(self.step*fromfunction(lambda i: i, [self.n]))
        w = w[1:] - w[:-1]
        return sum(0.5 * w * (vals[:-1] + vals[1:]))

    def logtrapzd(self, select=None):
        &#34;&#34;&#34;Return the log of the trapezoid rule quadrature of the values on the grid, 
        treating them as the log of the integrand.&#34;&#34;&#34;

        # An empty grid gives an error!
        if self.vals is None:
            raise RuntimeError(&#34;grid values not yet set!&#34;)

        # Make an array of step sizes.
        if self.isLin:
            w = zeros(self.n-1, float) + self.step
        else:
            w = self.absc
            if w is None:
                w = self.lo * exp(self.step*fromfunction(lambda i: i, [self.n]))
            w = w[1:] - w[:-1]

        # Pick out the values to use if we have a grid of tuples.
        if self.valSeq:
            if select is None:
                raise ValueError(&#34;must set select!&#34;)
            vals = self.vals[:, select]
        else:
            if select is not None:
                raise ValueError(&#34;Grid function is a scalar!&#34;)
            vals = self.vals

        # Calculate with respect to the max to avoid overflow.
        fmax = max(vals)
        fvals = exp(clip(vals-fmax, smallExp, 0.))
        s = sum(0.5 * w * (fvals[:-1] + fvals[1:]))
        return fmax + log(s)

    def logtrapzd_mom(self, nmom=None, select=None):
        &#34;&#34;&#34;
        Return the log of the trapezoid rule quadrature of the values on the grid, 
        treating them as the log of the integrand.  Also return up to two moments,
        divided by the quadrature.
        &#34;&#34;&#34;

        # An empty grid gives an error!
        if self.vals is None:
            raise RuntimeError(&#34;grid values not yet set!&#34;)

        # Only accept 1 or 2 moments.
        if nmom:
            if nmom != 1 and nmom != 2:
                raise ValueError(&#39;Only 1st and/or 2nd moment available!&#39;)

        # Make an array of step sizes.  Calculate abscissas (needed for moments).
        if self.absc is None:
            if self.isLin:
                self.absc = self.lo + self.step*fromfunction(lambda i: i, [self.n])
            else:
                self.absc = self.lo * exp(self.step*fromfunction(lambda i: i, [self.n]))
        w = self.absc[1:] - self.absc[:-1]

        # Pick out the values to use if we have a grid of tuples.
        if self.valSeq:
            if select is None:
                raise ValueError(&#34;must set select!&#34;)
            vals = self.vals[:, select]
        else:
            if select is not None:
                raise ValueError(&#34;Grid function is a scalar!&#34;)
            vals = self.vals

        # Calculate with respect to the max to avoid overflow.
        fmax = max(vals)
        fvals = exp(clip(vals-fmax, smallExp, 0.))
        s = sum(0.5 * w * (fvals[:-1] + fvals[1:]))
        quad = fmax + log(s)
        if not nmom:
            return quad
        # Adjust fvals so quad is factored out.  We&#39;ll report moments
        # up to a factor of exp(quad); we can&#39;t just report their logarithms
        # because moments can be negative.
        fvals = fvals * exp(fmax-quad)
        ignd = self.absc*fvals
        mom1 = sum(0.5 * w * (ignd[:-1] + ignd[1:]))
        if nmom == 1:
            return quad, mom1
        else:
            ignd = self.absc*ignd
            mom2 = sum(0.5 * w * (ignd[:-1] + ignd[1:]))
            return quad, mom1, mom2

    def subgrid(self, lo, hi):
        &#34;&#34;&#34;Create a subgrid of this grid, with data elements pointing
        to slices of this grid&#39;s data as appropriate.&#34;&#34;&#34;

        # Only subgrid if (lo,hi) are grid points.  They must match an existing
        # point to within 1e-3 of a step.
        if lo &lt; self.lo or hi &gt; self.hi:
            raise ValueError(&#34;subgrid out of range!&#34;)
        if self.isLin:
            lnum = lo-self.lo
            rlo = lnum/self.step
            hnum = hi-self.lo
            rhi = hnum/self.step
        else:
            lnum = log(lo/self.lo)
            rlo = lnum/self.step
            hnum = log(hi/self.lo)
            rhi = hnum/self.step
        nlo = int(round(rlo,2))
        if abs(nlo*self.step-lnum) &gt; 1.e-3*self.step:
            raise ValueError(&#34;lo doesn&#39;t match a grid pt!&#34;)
        nhi = int(round(rhi,2))
        if abs(nhi*self.step-hnum) &gt; 1.e-3*self.step:
            raise ValueError(&#34;hi doesn&#39;t match a grid pt!&#34;)

        # Make the grid and copy the data.
        n = nhi - nlo + 1
        if self.isLin:
            grid = BasicGrid1D(lo, hi, n, Lin, self.lml, self.rank)
        else:
            grid = BasicGrid1D(lo, hi, n, Log, self.lml, self.rank)
        if self.absc is not None:
            grid.absc = self.absc[nlo:nhi+1]
        if self.vals is not None:
            grid.vals = self.vals[nlo:nhi+1]
        grid.valSeq = self.valSeq
        return grid


################################################################################
class Grid1D:
    &#34;&#34;&#34;Create a 1-d grid with automated evaluation of a function and single-pass
    refinement in neighborhoods of local maxima.&#34;&#34;&#34;

    def __init__(self, lo, hi, n, stype=&#34;linear&#34;, nmax=None, dynrange=1.e5,
                 sigpts=11, nsig=4, rank=&#39;peak&#39;):
        &#34;&#34;&#34;Define the base grid and parameters defining the refinement.
        There will be sigpts new points per each +-sigma range, for
        nsig sigmas.

        Keep track of peaks according to peak amplitude by default; rank=&#39;area&#39;
        uses peak area instead.  Note that using peak area is trouble-prone if
        there are many close or overlapping peaks; the estimated peak area may
        include several peaks, with large but narrow peaks getting bypassed as a
        result of their smaller area.
        &#34;&#34;&#34;

        self.nmax = nmax
        self.lml = LabeledMaxList(nmax=nmax, dynrange=dynrange)
        self.stype = stype
        self.base = BasicGrid1D(lo, hi, n, stype, lml=self.lml, rank=rank)
        self.ilist = RefinedIntervalList1D(lo, hi, n, stype)
        self.nsig = nsig
        self.rank = rank
        self.rpts = nsig*(sigpts-1) + 1
        self.totpts = n
        self.func = None
        self.glist = [self.base]

    def __len__(self):
        &#34;&#34;&#34;Total # of pts in the refined grid.&#34;&#34;&#34;

        return self.totpts

    def __getitem__(self, n):
        &#34;&#34;&#34;
        Return (absc, width, value) associated with point # n (0-based).
        &#34;&#34;&#34;

        # Find the interval containing pt n; return the data.
        i, indx, intvl = self.ilist.nlocate(n)
        return self.glist[i].point(indx)

    def __iter__(self):
        i = 0
        while 1:
            try:
                yield self.__getitem__[i]
            except IndexError:
                raise StopIteration
            i += 1

    def firstpass(self, f, select=None, notify=None):
        &#34;&#34;&#34;Apply func on the base grid.&#34;&#34;&#34;

        self.func = f
        self.select = select
        self.base.stepfunc(f, select=select, notify=notify)

    def refine(self, dynrange=None, notify=None):
        &#34;&#34;&#34;Refine the grid at the maxima.
        Note:  The boundary values are recomputed for each subgrid,
        resulting in a small inefficiency.&#34;&#34;&#34;

        # Make sure we&#39;ve done a firstpass.
        if self.func is None:
            raise RuntimeError(&#34;Must do firstpass before refine!&#34;)

        # Limit the dynamic range to consider for the refinement, if requested.
        if dynrange:
            self.lml.limitRange(dynrange)

        # First, refine the interval list.
        for (A, label) in self.lml:
            lo = label[2] - self.nsig*label[3]
            hi = label[2] + self.nsig*label[3]
            self.ilist.update(lo, hi, self.rpts)
        self.totpts = self.ilist.npts

        # Make a list of grids associated with each interval.  Intervals with step
        # size equal to the base step size are assigned subgrids of the base grid.
        self.glist = []
        self.rlml = LabeledMaxList(self.nmax)
        for intvl in self.ilist:
            if intvl.step == self.ilist.base.step:
                self.glist.append(self.base.subgrid(intvl.lo,intvl.hi))
            else:
                self.glist.append(BasicGrid1D(intvl.lo, intvl.hi, intvl.n,
                                              self.stype, lml=self.rlml, rank=self.rank))

        # Go thru the grid list, evaluating the function and compiling a refined
        # list of labeled maxima.  But don&#39;t duplicate the work done on the base!
        if notify is not None:
            print(&#34;Refining among &#34;,len(self.glist), &#34; subgrids:&#34;)
        for grid in self.glist:
            if grid.step != self.base.step:
                if notify is not None:
                    print(&#34;&gt;&gt;&gt;Refining over [&#34;,grid.lo,&#34;, &#34;,grid.hi,&#34;]...&#34;)
                grid.stepfunc(self.func, select=self.select, notify=notify)

    def point(self, n):
        &#34;&#34;&#34;Return (absc, width, value) associated with point # n (0-based).&#34;&#34;&#34;

        # Find the interval containing pt n; return the data.
        i, indx, intvl = self.ilist.nlocate(n)
        return self.glist[i].point(indx)

    def trapzd(self, select=None):
        &#34;&#34;&#34;Return the trapezoid rule quadrature based on the current grid.&#34;&#34;&#34;

        # Sum over the refined grids.
        gsum = 0.
        for grid in self.glist:
            gsum = gsum + grid.trapzd(select=select)
        return gsum

    def logtrapzd(self, select=None):
        &#34;&#34;&#34;Return the log trapezoid rule quadrature based on the current grid,
        treating the function values as logs of the integrand.&#34;&#34;&#34;

        # Sum over the refined grids taking care to avoid overflows.
        lsum = self.glist[0].logtrapzd(select=select)
        # print &#39;first term = &#39;, exp(lsum)
        for grid in self.glist[1:]:
            l = grid.logtrapzd(select=select)
            # print repr(grid.lo), repr(grid.hi), grid.vals[0], grid.vals[-1], exp(l)
            if l &gt; lsum:
                l, lsum = lsum, l
            lsum += log(1. + exp(l-lsum))
            # if l &lt;= lsum:
            #    lsum += log(1. + exp(l-lsum))
            # else:
            #    lsum = l + log(1. + exp(lsum-l))
            #lsum = log( exp(lsum) + exp(l) )
        return lsum

    def logtrapzd_mom(self, nmom=None, select=None):
        &#34;&#34;&#34;Return the log trapezoid rule quadrature based on the current grid,
        treating the function values as logs of the integrand.  Also return
        the 1st and/or 2nd moments.&#34;&#34;&#34;

        if not nmom:
            return self.trapzd_log(select)

        # Sum over the refined grids taking care to avoid overflows.
        vals = []
        for grid in self.glist:
            vals.append(grid.logtrapzd_mom(nmom, select))
        vals = array(vals)
        # The log integral:
        qvals = vals[:,0]
        qmax = qvals.max()
        lquad = qmax + log(sum(exp(qvals-qmax)))
        # The first moment, up to a factor exp(lquad).
        facs = exp(qvals - lquad)
        mom1 = sum(facs*vals[:,1])
        if nmom == 1:
            return lquad, mom1
        else:
            mom2 = sum(facs*vals[:,2])
            return lquad, mom1, mom2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="inference.grid.grid1d.Grid1D"><code class="flex name class">
<span>class <span class="ident">Grid1D</span></span>
<span>(</span><span>lo, hi, n, stype='linear', nmax=None, dynrange=100000.0, sigpts=11, nsig=4, rank='peak')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 1-d grid with automated evaluation of a function and single-pass
refinement in neighborhoods of local maxima.</p>
<p>Define the base grid and parameters defining the refinement.
There will be sigpts new points per each +-sigma range, for
nsig sigmas.</p>
<p>Keep track of peaks according to peak amplitude by default; rank='area'
uses peak area instead.
Note that using peak area is trouble-prone if
there are many close or overlapping peaks; the estimated peak area may
include several peaks, with large but narrow peaks getting bypassed as a
result of their smaller area.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid1D:
    &#34;&#34;&#34;Create a 1-d grid with automated evaluation of a function and single-pass
    refinement in neighborhoods of local maxima.&#34;&#34;&#34;

    def __init__(self, lo, hi, n, stype=&#34;linear&#34;, nmax=None, dynrange=1.e5,
                 sigpts=11, nsig=4, rank=&#39;peak&#39;):
        &#34;&#34;&#34;Define the base grid and parameters defining the refinement.
        There will be sigpts new points per each +-sigma range, for
        nsig sigmas.

        Keep track of peaks according to peak amplitude by default; rank=&#39;area&#39;
        uses peak area instead.  Note that using peak area is trouble-prone if
        there are many close or overlapping peaks; the estimated peak area may
        include several peaks, with large but narrow peaks getting bypassed as a
        result of their smaller area.
        &#34;&#34;&#34;

        self.nmax = nmax
        self.lml = LabeledMaxList(nmax=nmax, dynrange=dynrange)
        self.stype = stype
        self.base = BasicGrid1D(lo, hi, n, stype, lml=self.lml, rank=rank)
        self.ilist = RefinedIntervalList1D(lo, hi, n, stype)
        self.nsig = nsig
        self.rank = rank
        self.rpts = nsig*(sigpts-1) + 1
        self.totpts = n
        self.func = None
        self.glist = [self.base]

    def __len__(self):
        &#34;&#34;&#34;Total # of pts in the refined grid.&#34;&#34;&#34;

        return self.totpts

    def __getitem__(self, n):
        &#34;&#34;&#34;
        Return (absc, width, value) associated with point # n (0-based).
        &#34;&#34;&#34;

        # Find the interval containing pt n; return the data.
        i, indx, intvl = self.ilist.nlocate(n)
        return self.glist[i].point(indx)

    def __iter__(self):
        i = 0
        while 1:
            try:
                yield self.__getitem__[i]
            except IndexError:
                raise StopIteration
            i += 1

    def firstpass(self, f, select=None, notify=None):
        &#34;&#34;&#34;Apply func on the base grid.&#34;&#34;&#34;

        self.func = f
        self.select = select
        self.base.stepfunc(f, select=select, notify=notify)

    def refine(self, dynrange=None, notify=None):
        &#34;&#34;&#34;Refine the grid at the maxima.
        Note:  The boundary values are recomputed for each subgrid,
        resulting in a small inefficiency.&#34;&#34;&#34;

        # Make sure we&#39;ve done a firstpass.
        if self.func is None:
            raise RuntimeError(&#34;Must do firstpass before refine!&#34;)

        # Limit the dynamic range to consider for the refinement, if requested.
        if dynrange:
            self.lml.limitRange(dynrange)

        # First, refine the interval list.
        for (A, label) in self.lml:
            lo = label[2] - self.nsig*label[3]
            hi = label[2] + self.nsig*label[3]
            self.ilist.update(lo, hi, self.rpts)
        self.totpts = self.ilist.npts

        # Make a list of grids associated with each interval.  Intervals with step
        # size equal to the base step size are assigned subgrids of the base grid.
        self.glist = []
        self.rlml = LabeledMaxList(self.nmax)
        for intvl in self.ilist:
            if intvl.step == self.ilist.base.step:
                self.glist.append(self.base.subgrid(intvl.lo,intvl.hi))
            else:
                self.glist.append(BasicGrid1D(intvl.lo, intvl.hi, intvl.n,
                                              self.stype, lml=self.rlml, rank=self.rank))

        # Go thru the grid list, evaluating the function and compiling a refined
        # list of labeled maxima.  But don&#39;t duplicate the work done on the base!
        if notify is not None:
            print(&#34;Refining among &#34;,len(self.glist), &#34; subgrids:&#34;)
        for grid in self.glist:
            if grid.step != self.base.step:
                if notify is not None:
                    print(&#34;&gt;&gt;&gt;Refining over [&#34;,grid.lo,&#34;, &#34;,grid.hi,&#34;]...&#34;)
                grid.stepfunc(self.func, select=self.select, notify=notify)

    def point(self, n):
        &#34;&#34;&#34;Return (absc, width, value) associated with point # n (0-based).&#34;&#34;&#34;

        # Find the interval containing pt n; return the data.
        i, indx, intvl = self.ilist.nlocate(n)
        return self.glist[i].point(indx)

    def trapzd(self, select=None):
        &#34;&#34;&#34;Return the trapezoid rule quadrature based on the current grid.&#34;&#34;&#34;

        # Sum over the refined grids.
        gsum = 0.
        for grid in self.glist:
            gsum = gsum + grid.trapzd(select=select)
        return gsum

    def logtrapzd(self, select=None):
        &#34;&#34;&#34;Return the log trapezoid rule quadrature based on the current grid,
        treating the function values as logs of the integrand.&#34;&#34;&#34;

        # Sum over the refined grids taking care to avoid overflows.
        lsum = self.glist[0].logtrapzd(select=select)
        # print &#39;first term = &#39;, exp(lsum)
        for grid in self.glist[1:]:
            l = grid.logtrapzd(select=select)
            # print repr(grid.lo), repr(grid.hi), grid.vals[0], grid.vals[-1], exp(l)
            if l &gt; lsum:
                l, lsum = lsum, l
            lsum += log(1. + exp(l-lsum))
            # if l &lt;= lsum:
            #    lsum += log(1. + exp(l-lsum))
            # else:
            #    lsum = l + log(1. + exp(lsum-l))
            #lsum = log( exp(lsum) + exp(l) )
        return lsum

    def logtrapzd_mom(self, nmom=None, select=None):
        &#34;&#34;&#34;Return the log trapezoid rule quadrature based on the current grid,
        treating the function values as logs of the integrand.  Also return
        the 1st and/or 2nd moments.&#34;&#34;&#34;

        if not nmom:
            return self.trapzd_log(select)

        # Sum over the refined grids taking care to avoid overflows.
        vals = []
        for grid in self.glist:
            vals.append(grid.logtrapzd_mom(nmom, select))
        vals = array(vals)
        # The log integral:
        qvals = vals[:,0]
        qmax = qvals.max()
        lquad = qmax + log(sum(exp(qvals-qmax)))
        # The first moment, up to a factor exp(lquad).
        facs = exp(qvals - lquad)
        mom1 = sum(facs*vals[:,1])
        if nmom == 1:
            return lquad, mom1
        else:
            mom2 = sum(facs*vals[:,2])
            return lquad, mom1, mom2</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="inference.grid.grid1d.Grid1D.firstpass"><code class="name flex">
<span>def <span class="ident">firstpass</span></span>(<span>self, f, select=None, notify=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply func on the base grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def firstpass(self, f, select=None, notify=None):
    &#34;&#34;&#34;Apply func on the base grid.&#34;&#34;&#34;

    self.func = f
    self.select = select
    self.base.stepfunc(f, select=select, notify=notify)</code></pre>
</details>
</dd>
<dt id="inference.grid.grid1d.Grid1D.logtrapzd"><code class="name flex">
<span>def <span class="ident">logtrapzd</span></span>(<span>self, select=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the log trapezoid rule quadrature based on the current grid,
treating the function values as logs of the integrand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logtrapzd(self, select=None):
    &#34;&#34;&#34;Return the log trapezoid rule quadrature based on the current grid,
    treating the function values as logs of the integrand.&#34;&#34;&#34;

    # Sum over the refined grids taking care to avoid overflows.
    lsum = self.glist[0].logtrapzd(select=select)
    # print &#39;first term = &#39;, exp(lsum)
    for grid in self.glist[1:]:
        l = grid.logtrapzd(select=select)
        # print repr(grid.lo), repr(grid.hi), grid.vals[0], grid.vals[-1], exp(l)
        if l &gt; lsum:
            l, lsum = lsum, l
        lsum += log(1. + exp(l-lsum))
        # if l &lt;= lsum:
        #    lsum += log(1. + exp(l-lsum))
        # else:
        #    lsum = l + log(1. + exp(lsum-l))
        #lsum = log( exp(lsum) + exp(l) )
    return lsum</code></pre>
</details>
</dd>
<dt id="inference.grid.grid1d.Grid1D.logtrapzd_mom"><code class="name flex">
<span>def <span class="ident">logtrapzd_mom</span></span>(<span>self, nmom=None, select=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the log trapezoid rule quadrature based on the current grid,
treating the function values as logs of the integrand.
Also return
the 1st and/or 2nd moments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logtrapzd_mom(self, nmom=None, select=None):
    &#34;&#34;&#34;Return the log trapezoid rule quadrature based on the current grid,
    treating the function values as logs of the integrand.  Also return
    the 1st and/or 2nd moments.&#34;&#34;&#34;

    if not nmom:
        return self.trapzd_log(select)

    # Sum over the refined grids taking care to avoid overflows.
    vals = []
    for grid in self.glist:
        vals.append(grid.logtrapzd_mom(nmom, select))
    vals = array(vals)
    # The log integral:
    qvals = vals[:,0]
    qmax = qvals.max()
    lquad = qmax + log(sum(exp(qvals-qmax)))
    # The first moment, up to a factor exp(lquad).
    facs = exp(qvals - lquad)
    mom1 = sum(facs*vals[:,1])
    if nmom == 1:
        return lquad, mom1
    else:
        mom2 = sum(facs*vals[:,2])
        return lquad, mom1, mom2</code></pre>
</details>
</dd>
<dt id="inference.grid.grid1d.Grid1D.point"><code class="name flex">
<span>def <span class="ident">point</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return (absc, width, value) associated with point # n (0-based).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point(self, n):
    &#34;&#34;&#34;Return (absc, width, value) associated with point # n (0-based).&#34;&#34;&#34;

    # Find the interval containing pt n; return the data.
    i, indx, intvl = self.ilist.nlocate(n)
    return self.glist[i].point(indx)</code></pre>
</details>
</dd>
<dt id="inference.grid.grid1d.Grid1D.refine"><code class="name flex">
<span>def <span class="ident">refine</span></span>(<span>self, dynrange=None, notify=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Refine the grid at the maxima.
Note:
The boundary values are recomputed for each subgrid,
resulting in a small inefficiency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refine(self, dynrange=None, notify=None):
    &#34;&#34;&#34;Refine the grid at the maxima.
    Note:  The boundary values are recomputed for each subgrid,
    resulting in a small inefficiency.&#34;&#34;&#34;

    # Make sure we&#39;ve done a firstpass.
    if self.func is None:
        raise RuntimeError(&#34;Must do firstpass before refine!&#34;)

    # Limit the dynamic range to consider for the refinement, if requested.
    if dynrange:
        self.lml.limitRange(dynrange)

    # First, refine the interval list.
    for (A, label) in self.lml:
        lo = label[2] - self.nsig*label[3]
        hi = label[2] + self.nsig*label[3]
        self.ilist.update(lo, hi, self.rpts)
    self.totpts = self.ilist.npts

    # Make a list of grids associated with each interval.  Intervals with step
    # size equal to the base step size are assigned subgrids of the base grid.
    self.glist = []
    self.rlml = LabeledMaxList(self.nmax)
    for intvl in self.ilist:
        if intvl.step == self.ilist.base.step:
            self.glist.append(self.base.subgrid(intvl.lo,intvl.hi))
        else:
            self.glist.append(BasicGrid1D(intvl.lo, intvl.hi, intvl.n,
                                          self.stype, lml=self.rlml, rank=self.rank))

    # Go thru the grid list, evaluating the function and compiling a refined
    # list of labeled maxima.  But don&#39;t duplicate the work done on the base!
    if notify is not None:
        print(&#34;Refining among &#34;,len(self.glist), &#34; subgrids:&#34;)
    for grid in self.glist:
        if grid.step != self.base.step:
            if notify is not None:
                print(&#34;&gt;&gt;&gt;Refining over [&#34;,grid.lo,&#34;, &#34;,grid.hi,&#34;]...&#34;)
            grid.stepfunc(self.func, select=self.select, notify=notify)</code></pre>
</details>
</dd>
<dt id="inference.grid.grid1d.Grid1D.trapzd"><code class="name flex">
<span>def <span class="ident">trapzd</span></span>(<span>self, select=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the trapezoid rule quadrature based on the current grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trapzd(self, select=None):
    &#34;&#34;&#34;Return the trapezoid rule quadrature based on the current grid.&#34;&#34;&#34;

    # Sum over the refined grids.
    gsum = 0.
    for grid in self.glist:
        gsum = gsum + grid.trapzd(select=select)
    return gsum</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="inference.grid" href="index.html">inference.grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="inference.grid.grid1d.Grid1D" href="#inference.grid.grid1d.Grid1D">Grid1D</a></code></h4>
<ul class="two-column">
<li><code><a title="inference.grid.grid1d.Grid1D.firstpass" href="#inference.grid.grid1d.Grid1D.firstpass">firstpass</a></code></li>
<li><code><a title="inference.grid.grid1d.Grid1D.logtrapzd" href="#inference.grid.grid1d.Grid1D.logtrapzd">logtrapzd</a></code></li>
<li><code><a title="inference.grid.grid1d.Grid1D.logtrapzd_mom" href="#inference.grid.grid1d.Grid1D.logtrapzd_mom">logtrapzd_mom</a></code></li>
<li><code><a title="inference.grid.grid1d.Grid1D.point" href="#inference.grid.grid1d.Grid1D.point">point</a></code></li>
<li><code><a title="inference.grid.grid1d.Grid1D.refine" href="#inference.grid.grid1d.Grid1D.refine">refine</a></code></li>
<li><code><a title="inference.grid.grid1d.Grid1D.trapzd" href="#inference.grid.grid1d.Grid1D.trapzd">trapzd</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>