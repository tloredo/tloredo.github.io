<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>inference.grid.hpd API documentation</title>
<meta name="description" content="Objects for calculating highest posterior density credible regions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>inference.grid.hpd</code></h1>
</header>
<section id="section-intro">
<p>Objects for calculating highest posterior density credible regions.</p>
<p>HPD1D and HPD2D find the boundaries of HPD regions using previously
calculated grids of 1-D or 2-D (log) probability densities (respectively).
They
are intended for use in settings where other tools will have already calculated
the grids (e.g., inference grids generated by PIE tools).
The pdf gets
(re)normalized over the grid; e.g., the grids may contain values of an
unnormalized prior*likelihood (the normalization constant is accessible as a
data attribute and may be useful for Bayesian model comparison).</p>
<p>See hpdgrid for versions that instead take probability density <em>functions</em>
and calculate the grids themselves.</p>
<p>By Tom Loredo</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Objects for calculating highest posterior density credible regions.

HPD1D and HPD2D find the boundaries of HPD regions using previously
calculated grids of 1-D or 2-D (log) probability densities (respectively).  They
are intended for use in settings where other tools will have already calculated
the grids (e.g., inference grids generated by PIE tools).  The pdf gets 
(re)normalized over the grid; e.g., the grids may contain values of an
unnormalized prior*likelihood (the normalization constant is accessible as a 
data attribute and may be useful for Bayesian model comparison).

See hpdgrid for versions that instead take probability density *functions*
and calculate the grids themselves.

By Tom Loredo
&#34;&#34;&#34;

from inference.utils.numutils import zbracket, lin_stepper, log_stepper
from scipy import exp, log, sqrt, pi, array, stats
from scipy.optimize import brentq
from ._gridquad import qgt1d, qgt2d, xvalues

__all__ = [&#39;HPD1D&#39;, &#39;HPD2D&#39;]

rt2pi = sqrt(2*pi)
stdnorm = stats.norm()


def sig2prob(nd, nsig):
    &#34;&#34;&#34;
    The probability within nsig std deviations of the mean of a n-dim normal
    distribution.
    &#34;&#34;&#34;
    # For 1d the upper tail area is given by the std normal survival function.
    #utail = stdnorm.sf(nsig)
    # return 1. - 2*utail
    return stats.chi2.cdf(nsig**2, nd)


def prob2sig(nd, p):
    &#34;&#34;&#34;
    The number of std deviations corresponding to probability p for n-dim normal.
    &#34;&#34;&#34;
    # These two lines are for the 1-d normal case.
    #utail = 0.5*(1.-p)
    # return stdnorm.isf(utail)
    return sqrt(stats.chi2.ppf(p, nd))


def prob2dens(nd, p):
    &#34;&#34;&#34;
    The n-dim normal PDF density bounding an HPD credible region of content p.
    &#34;&#34;&#34;
    nsig = prob2sig(nd, p)
    return exp(-0.5*nd * nsig**2)/rt2pi**nd


def prob2ratio(nd, p):
    &#34;&#34;&#34;
    The relative normal PDF density bounding an HPD credible region
    of content p (relative to the peak density).
    &#34;&#34;&#34;
    nsig = prob2sig(nd, p)
    return exp(-0.5*nd * nsig**2)


def sig2ratio(nd, nsig):
    &#34;&#34;&#34;
    The relative normal PDF density bounding an HPD credible region
    spanning nsig std deviations (relative to the peak density).
    &#34;&#34;&#34;
    return exp(-0.5*nd * nsig**2)


class HPD1D(object):
    &#34;&#34;&#34;
    Calculate 1-D HPD region boundaries from a grid of (log) pdf values.

    For grid spacing linear in x, the regions are for p(x).  For grid spacing 
    linear in log(x), the regions are for p(log x), but with boundaries
    specified in terms of x itself, i.e., appropriate for use on plots of 
    p(log x) (equal to x*p(x)) vs. x with a logarithmic abscissa.
    &#34;&#34;&#34;

    # Probabilities associated with normal dist&#39;n &#34;sigmas&#34;:
    p1sig, p2sig, p3sig = sig2prob(1,1), sig2prob(1,2), sig2prob(1,3)

    # Corresponding relative PDF levels defining normal HPD regions,
    # to use as starting points:
    ratio1 = sig2ratio(1,1)
    ratio2 = sig2ratio(1,2)
    ratio3 = sig2ratio(1,3)

    def __init__(self, logpdf, xlo, xhi, step=&#39;linear&#39;):
        &#34;&#34;&#34;
        Initialize the HPDGrid1D object.

        :Parameters:

          logpdf : float array
            Array of log pdf values

          xlo, xhi : float
            Range spanned by logpdf

          step : &#39;linear&#39; OR &#39;lin&#39; OR &#39;logarithmic&#39; OR &#39;log&#39;
            &#39;linear&#39; for a grid linear in x; &#39;log&#39; for a grid linear in log(x)
        &#34;&#34;&#34;
        if len(logpdf.shape) != 1:
            raise ValueError(&#39;logpdf array must be 1-d!&#39;)
        self.logpdf = logpdf
        self.xlo, self.xhi = xlo, xhi
        self.nx = logpdf.shape[0]
        if step == &#39;linear&#39; or step == &#39;lin&#39;:
            self.linstep = True
            self.xvals = array([x for x in lin_stepper(xlo, xhi, self.nx)])
            self.dx = (xhi-xlo)/(self.nx-1.)
        elif step == &#39;log&#39; or step == &#39;logarithmic&#39;:
            self.linstep = False
            self.xvals = [x for x in log_stepper(xlo, xhi, self.nx)]
            self.dx = log(xhi/xlo)/(self.nx-1)
        else:
            raise ValueError(&#39;Invalid step type!&#39;)
        self.max = logpdf.max()
        self.spdf = exp(logpdf-self.max)  # scaled PDF
        # For log steps, change variables to log(x).
        if not self.linstep:
            for i, x in enumerate(self.xvals):
                self.spdf[i] = self.spdf[i]*x
        # Find the overall normalization for spdf.
        self.snorm = qgt1d(self.spdf, self.spdf.min())*self.dx
        # lml is the log marginal likelihood if logpdf = prior*like.
        self.lml = log(self.snorm) + self.max
        self.probs = []
        self.deltas = []
        self.levels = []
        self.bounds = []

    def norm(self):
        &#34;&#34;&#34;
        Return the log of the normalization constant for the grid.

        If the log_pdf function is prior*likelihood, this is the marginal
        likelihood.
        &#34;&#34;&#34;
        return log(self.snorm) + self.max

    def fracgt(self, logratio):
        &#34;&#34;&#34;
        The fraction of the posterior with log density &gt; maximum + logratio.
        &#34;&#34;&#34;
        ratio = exp(logratio)
        return qgt1d(self.spdf, ratio)*self.dx/self.snorm

    def critlevel(self, p=None, snsig=None, tol=3.e-4):
        &#34;&#34;&#34;
        The log critical PDF ratio (wrt mode) bounding an HPD credible region
        with probability p.
        &#34;&#34;&#34;
        # Take as an initial guess the ratio for a 1-d normal.
        if snsig:
            if p:
                raise ValueError(&#39;Provide only one of p, snsig!&#39;)
            lr1 = log(sig2ratio(1, snsig))
            p = sig2prob(1, snsig)
        else:
            lr1 = log(prob2ratio(1, p))
        # Use the guess to bracket the solution and then solve.
        lr2 = lr1 - 0.1
        # print &#39;Guesses:&#39;, lr1, lr2
        self._target = p
        lr1, lr2 = zbracket(self._diff, lr1, lr2)
        # print &#39;Bracket:&#39;, lr1, lr2
        logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
        # print repr(logratio)
        self.probs.append(p)
        self.deltas.append(logratio)
        self.levels.append(self.max+logratio)
        # 10 is the max # boundaries; it should handle pretty bumpy PDFs!
        bounds, nb, ok = xvalues(self.xvals, self.logpdf-self.max, logratio, 10)
        if not ok:
            raise RuntimeError(&#39;Too many boundary points in PDF!&#39;)
        bounds = bounds[:nb]
        self.bounds.append(bounds)
        return logratio, bounds

    def _diff(self, logratio):
        &#34;&#34;&#34;
        The function whose zero gives critRatio; it is fracgt - target prob.
        &#34;&#34;&#34;
        return self.fracgt(logratio) - self._target


class HPD2D(object):
    &#34;&#34;&#34;
    Calculate 2-D HPD region boundaries from a grid of (log) pdf values.
    &#34;&#34;&#34;

    # Probabilities associated with normal dist&#39;n &#34;sigmas&#34;:
    p1sig, p2sig, p3sig = sig2prob(2,1), sig2prob(2,2), sig2prob(2,3)

    # Corresponding relative PDF levels defining normal HPD regions,
    # to use as starting points:
    ratio1 = sig2ratio(2,1)
    ratio2 = sig2ratio(2,2)
    ratio3 = sig2ratio(2,3)

    def __init__(self, logpdf, xlo, xhi, ylo, yhi, xstep=&#39;linear&#39;, ystep=&#39;linear&#39;):
        if len(logpdf.shape) != 2:
            raise ValueError(&#39;logpdf array must be 2-d!&#39;)
        self.logpdf = logpdf
        self.xlo, self.xhi = xlo, xhi
        self.nx = logpdf.shape[0]
        if xstep == &#39;linear&#39; or xstep == &#39;lin&#39;:
            self.xlinstep = True
            self.xvals = array([x for x in lin_stepper(xlo, xhi, self.nx)])
            self.dx = (xhi-xlo)/(self.nx-1)
        elif xstep == &#39;log&#39; or xstep == &#39;logarithmic&#39;:
            self.xlinstep = False
            self.xvals = array([x for x in log_stepper(xlo, xhi, self.nx)])
            self.dx = log(xhi/xlo)/(self.nx-1)
        else:
            raise ValueError(&#39;Invalid xstep type!&#39;)
        self.ylo, selfyxhi = ylo, yhi
        self.ny = logpdf.shape[1]
        if ystep == &#39;linear&#39; or ystep == &#39;lin&#39;:
            self.ylinstep = True
            self.yvals = array([y for y in lin_stepper(ylo, yhi, self.ny)])
            self.dy = (yhi-ylo)/(self.ny-1)
        elif ystep == &#39;log&#39; or ystep == &#39;logarithmic&#39;:
            self.ylinstep = False
            self.yvals = array([y for y in log_stepper(ylo, yhi, self.ny)])
            self.dy = log(yhi/ylo)/(self.ny-1)
        else:
            raise ValueError(&#39;Invalid ystep type!&#39;)
        self.max = logpdf.max()
        self.spdf = exp(logpdf-self.max)  # Scaled PDF
        # For log steps, change variables to log(x or y).
        if not self.xlinstep:
            for i, x in enumerate(self.xvals):
                self.spdf[i,:] = self.spdf[i,:]*x
        if not self.ylinstep:
            for j, y in enumerate(self.yvals):
                self.spdf[:,j] = self.spdf[:,j]*y
        # Find the overall normalization for spdf.
        self.norm = qgt2d(self.spdf, self.spdf.min())*self.dx*self.dy
        # lml is the log marginal likelihood if logpdf = prior*like.
        self.lml = log(self.norm) + self.max
        self.probs = []
        self.deltas = []
        self.levels = []

    def fracgt(self, logratio):
        &#34;&#34;&#34;
        The fraction of the posterior with log density &gt; maximum + logratio.
        &#34;&#34;&#34;
        ratio = exp(logratio)
        return qgt2d(self.spdf, ratio)*self.dx*self.dy/self.norm

    def critlevel(self, p=None, snsig=None, tol=3.e-4):
        &#34;&#34;&#34;
        The log critical PDF ratio (wrt mode) bounding an HPD credible region
        with probability p.
        &#34;&#34;&#34;
        # Take as an initial guess the ratio for a 1-d normal.
        if snsig:
            if p:
                raise ValueError(&#39;Provide only one of p, snsig!&#39;)
            lr1 = log(sig2ratio(1, snsig))
            p = sig2prob(1, snsig)
        else:
            lr1 = log(prob2ratio(1, p))
        p = float(p)  # Otherwise it may be a scalar array.
        # Use this to bracket the solution and then solve.
        lr2 = lr1 - 0.1
        # print &#39;Guesses:&#39;, lr1, lr2
        self._target = p
        lr1, lr2 = zbracket(self._diff, lr1, lr2)
        # print &#39;Bracket:&#39;, lr1, lr2
        logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
        # print repr(logratio)
        self.probs.append(p)
        self.deltas.append(logratio)
        self.levels.append(self.max+logratio)
        return logratio

    def _diff(self, logratio):
        &#34;&#34;&#34;The function whose zero gives critRatio; it is fracgt - target prob.&#34;&#34;&#34;
        return self.fracgt(logratio) - self._target</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="inference.grid.hpd.HPD1D"><code class="flex name class">
<span>class <span class="ident">HPD1D</span></span>
<span>(</span><span>logpdf, xlo, xhi, step='linear')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 1-D HPD region boundaries from a grid of (log) pdf values.</p>
<p>For grid spacing linear in x, the regions are for p(x).
For grid spacing
linear in log(x), the regions are for p(log x), but with boundaries
specified in terms of x itself, i.e., appropriate for use on plots of
p(log x) (equal to x*p(x)) vs. x with a logarithmic abscissa.</p>
<p>Initialize the HPDGrid1D object.</p>
<p>:Parameters:</p>
<p>logpdf : float array
Array of log pdf values</p>
<p>xlo, xhi : float
Range spanned by logpdf</p>
<p>step : 'linear' OR 'lin' OR 'logarithmic' OR 'log'
'linear' for a grid linear in x; 'log' for a grid linear in log(x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HPD1D(object):
    &#34;&#34;&#34;
    Calculate 1-D HPD region boundaries from a grid of (log) pdf values.

    For grid spacing linear in x, the regions are for p(x).  For grid spacing 
    linear in log(x), the regions are for p(log x), but with boundaries
    specified in terms of x itself, i.e., appropriate for use on plots of 
    p(log x) (equal to x*p(x)) vs. x with a logarithmic abscissa.
    &#34;&#34;&#34;

    # Probabilities associated with normal dist&#39;n &#34;sigmas&#34;:
    p1sig, p2sig, p3sig = sig2prob(1,1), sig2prob(1,2), sig2prob(1,3)

    # Corresponding relative PDF levels defining normal HPD regions,
    # to use as starting points:
    ratio1 = sig2ratio(1,1)
    ratio2 = sig2ratio(1,2)
    ratio3 = sig2ratio(1,3)

    def __init__(self, logpdf, xlo, xhi, step=&#39;linear&#39;):
        &#34;&#34;&#34;
        Initialize the HPDGrid1D object.

        :Parameters:

          logpdf : float array
            Array of log pdf values

          xlo, xhi : float
            Range spanned by logpdf

          step : &#39;linear&#39; OR &#39;lin&#39; OR &#39;logarithmic&#39; OR &#39;log&#39;
            &#39;linear&#39; for a grid linear in x; &#39;log&#39; for a grid linear in log(x)
        &#34;&#34;&#34;
        if len(logpdf.shape) != 1:
            raise ValueError(&#39;logpdf array must be 1-d!&#39;)
        self.logpdf = logpdf
        self.xlo, self.xhi = xlo, xhi
        self.nx = logpdf.shape[0]
        if step == &#39;linear&#39; or step == &#39;lin&#39;:
            self.linstep = True
            self.xvals = array([x for x in lin_stepper(xlo, xhi, self.nx)])
            self.dx = (xhi-xlo)/(self.nx-1.)
        elif step == &#39;log&#39; or step == &#39;logarithmic&#39;:
            self.linstep = False
            self.xvals = [x for x in log_stepper(xlo, xhi, self.nx)]
            self.dx = log(xhi/xlo)/(self.nx-1)
        else:
            raise ValueError(&#39;Invalid step type!&#39;)
        self.max = logpdf.max()
        self.spdf = exp(logpdf-self.max)  # scaled PDF
        # For log steps, change variables to log(x).
        if not self.linstep:
            for i, x in enumerate(self.xvals):
                self.spdf[i] = self.spdf[i]*x
        # Find the overall normalization for spdf.
        self.snorm = qgt1d(self.spdf, self.spdf.min())*self.dx
        # lml is the log marginal likelihood if logpdf = prior*like.
        self.lml = log(self.snorm) + self.max
        self.probs = []
        self.deltas = []
        self.levels = []
        self.bounds = []

    def norm(self):
        &#34;&#34;&#34;
        Return the log of the normalization constant for the grid.

        If the log_pdf function is prior*likelihood, this is the marginal
        likelihood.
        &#34;&#34;&#34;
        return log(self.snorm) + self.max

    def fracgt(self, logratio):
        &#34;&#34;&#34;
        The fraction of the posterior with log density &gt; maximum + logratio.
        &#34;&#34;&#34;
        ratio = exp(logratio)
        return qgt1d(self.spdf, ratio)*self.dx/self.snorm

    def critlevel(self, p=None, snsig=None, tol=3.e-4):
        &#34;&#34;&#34;
        The log critical PDF ratio (wrt mode) bounding an HPD credible region
        with probability p.
        &#34;&#34;&#34;
        # Take as an initial guess the ratio for a 1-d normal.
        if snsig:
            if p:
                raise ValueError(&#39;Provide only one of p, snsig!&#39;)
            lr1 = log(sig2ratio(1, snsig))
            p = sig2prob(1, snsig)
        else:
            lr1 = log(prob2ratio(1, p))
        # Use the guess to bracket the solution and then solve.
        lr2 = lr1 - 0.1
        # print &#39;Guesses:&#39;, lr1, lr2
        self._target = p
        lr1, lr2 = zbracket(self._diff, lr1, lr2)
        # print &#39;Bracket:&#39;, lr1, lr2
        logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
        # print repr(logratio)
        self.probs.append(p)
        self.deltas.append(logratio)
        self.levels.append(self.max+logratio)
        # 10 is the max # boundaries; it should handle pretty bumpy PDFs!
        bounds, nb, ok = xvalues(self.xvals, self.logpdf-self.max, logratio, 10)
        if not ok:
            raise RuntimeError(&#39;Too many boundary points in PDF!&#39;)
        bounds = bounds[:nb]
        self.bounds.append(bounds)
        return logratio, bounds

    def _diff(self, logratio):
        &#34;&#34;&#34;
        The function whose zero gives critRatio; it is fracgt - target prob.
        &#34;&#34;&#34;
        return self.fracgt(logratio) - self._target</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="inference.grid.hpd.HPD1D.p1sig"><code class="name">var <span class="ident">p1sig</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD1D.p2sig"><code class="name">var <span class="ident">p2sig</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD1D.p3sig"><code class="name">var <span class="ident">p3sig</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD1D.ratio1"><code class="name">var <span class="ident">ratio1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD1D.ratio2"><code class="name">var <span class="ident">ratio2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD1D.ratio3"><code class="name">var <span class="ident">ratio3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="inference.grid.hpd.HPD1D.critlevel"><code class="name flex">
<span>def <span class="ident">critlevel</span></span>(<span>self, p=None, snsig=None, tol=0.0003)</span>
</code></dt>
<dd>
<div class="desc"><p>The log critical PDF ratio (wrt mode) bounding an HPD credible region
with probability p.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def critlevel(self, p=None, snsig=None, tol=3.e-4):
    &#34;&#34;&#34;
    The log critical PDF ratio (wrt mode) bounding an HPD credible region
    with probability p.
    &#34;&#34;&#34;
    # Take as an initial guess the ratio for a 1-d normal.
    if snsig:
        if p:
            raise ValueError(&#39;Provide only one of p, snsig!&#39;)
        lr1 = log(sig2ratio(1, snsig))
        p = sig2prob(1, snsig)
    else:
        lr1 = log(prob2ratio(1, p))
    # Use the guess to bracket the solution and then solve.
    lr2 = lr1 - 0.1
    # print &#39;Guesses:&#39;, lr1, lr2
    self._target = p
    lr1, lr2 = zbracket(self._diff, lr1, lr2)
    # print &#39;Bracket:&#39;, lr1, lr2
    logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
    # print repr(logratio)
    self.probs.append(p)
    self.deltas.append(logratio)
    self.levels.append(self.max+logratio)
    # 10 is the max # boundaries; it should handle pretty bumpy PDFs!
    bounds, nb, ok = xvalues(self.xvals, self.logpdf-self.max, logratio, 10)
    if not ok:
        raise RuntimeError(&#39;Too many boundary points in PDF!&#39;)
    bounds = bounds[:nb]
    self.bounds.append(bounds)
    return logratio, bounds</code></pre>
</details>
</dd>
<dt id="inference.grid.hpd.HPD1D.fracgt"><code class="name flex">
<span>def <span class="ident">fracgt</span></span>(<span>self, logratio)</span>
</code></dt>
<dd>
<div class="desc"><p>The fraction of the posterior with log density &gt; maximum + logratio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fracgt(self, logratio):
    &#34;&#34;&#34;
    The fraction of the posterior with log density &gt; maximum + logratio.
    &#34;&#34;&#34;
    ratio = exp(logratio)
    return qgt1d(self.spdf, ratio)*self.dx/self.snorm</code></pre>
</details>
</dd>
<dt id="inference.grid.hpd.HPD1D.norm"><code class="name flex">
<span>def <span class="ident">norm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the log of the normalization constant for the grid.</p>
<p>If the log_pdf function is prior*likelihood, this is the marginal
likelihood.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm(self):
    &#34;&#34;&#34;
    Return the log of the normalization constant for the grid.

    If the log_pdf function is prior*likelihood, this is the marginal
    likelihood.
    &#34;&#34;&#34;
    return log(self.snorm) + self.max</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="inference.grid.hpd.HPD2D"><code class="flex name class">
<span>class <span class="ident">HPD2D</span></span>
<span>(</span><span>logpdf, xlo, xhi, ylo, yhi, xstep='linear', ystep='linear')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 2-D HPD region boundaries from a grid of (log) pdf values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HPD2D(object):
    &#34;&#34;&#34;
    Calculate 2-D HPD region boundaries from a grid of (log) pdf values.
    &#34;&#34;&#34;

    # Probabilities associated with normal dist&#39;n &#34;sigmas&#34;:
    p1sig, p2sig, p3sig = sig2prob(2,1), sig2prob(2,2), sig2prob(2,3)

    # Corresponding relative PDF levels defining normal HPD regions,
    # to use as starting points:
    ratio1 = sig2ratio(2,1)
    ratio2 = sig2ratio(2,2)
    ratio3 = sig2ratio(2,3)

    def __init__(self, logpdf, xlo, xhi, ylo, yhi, xstep=&#39;linear&#39;, ystep=&#39;linear&#39;):
        if len(logpdf.shape) != 2:
            raise ValueError(&#39;logpdf array must be 2-d!&#39;)
        self.logpdf = logpdf
        self.xlo, self.xhi = xlo, xhi
        self.nx = logpdf.shape[0]
        if xstep == &#39;linear&#39; or xstep == &#39;lin&#39;:
            self.xlinstep = True
            self.xvals = array([x for x in lin_stepper(xlo, xhi, self.nx)])
            self.dx = (xhi-xlo)/(self.nx-1)
        elif xstep == &#39;log&#39; or xstep == &#39;logarithmic&#39;:
            self.xlinstep = False
            self.xvals = array([x for x in log_stepper(xlo, xhi, self.nx)])
            self.dx = log(xhi/xlo)/(self.nx-1)
        else:
            raise ValueError(&#39;Invalid xstep type!&#39;)
        self.ylo, selfyxhi = ylo, yhi
        self.ny = logpdf.shape[1]
        if ystep == &#39;linear&#39; or ystep == &#39;lin&#39;:
            self.ylinstep = True
            self.yvals = array([y for y in lin_stepper(ylo, yhi, self.ny)])
            self.dy = (yhi-ylo)/(self.ny-1)
        elif ystep == &#39;log&#39; or ystep == &#39;logarithmic&#39;:
            self.ylinstep = False
            self.yvals = array([y for y in log_stepper(ylo, yhi, self.ny)])
            self.dy = log(yhi/ylo)/(self.ny-1)
        else:
            raise ValueError(&#39;Invalid ystep type!&#39;)
        self.max = logpdf.max()
        self.spdf = exp(logpdf-self.max)  # Scaled PDF
        # For log steps, change variables to log(x or y).
        if not self.xlinstep:
            for i, x in enumerate(self.xvals):
                self.spdf[i,:] = self.spdf[i,:]*x
        if not self.ylinstep:
            for j, y in enumerate(self.yvals):
                self.spdf[:,j] = self.spdf[:,j]*y
        # Find the overall normalization for spdf.
        self.norm = qgt2d(self.spdf, self.spdf.min())*self.dx*self.dy
        # lml is the log marginal likelihood if logpdf = prior*like.
        self.lml = log(self.norm) + self.max
        self.probs = []
        self.deltas = []
        self.levels = []

    def fracgt(self, logratio):
        &#34;&#34;&#34;
        The fraction of the posterior with log density &gt; maximum + logratio.
        &#34;&#34;&#34;
        ratio = exp(logratio)
        return qgt2d(self.spdf, ratio)*self.dx*self.dy/self.norm

    def critlevel(self, p=None, snsig=None, tol=3.e-4):
        &#34;&#34;&#34;
        The log critical PDF ratio (wrt mode) bounding an HPD credible region
        with probability p.
        &#34;&#34;&#34;
        # Take as an initial guess the ratio for a 1-d normal.
        if snsig:
            if p:
                raise ValueError(&#39;Provide only one of p, snsig!&#39;)
            lr1 = log(sig2ratio(1, snsig))
            p = sig2prob(1, snsig)
        else:
            lr1 = log(prob2ratio(1, p))
        p = float(p)  # Otherwise it may be a scalar array.
        # Use this to bracket the solution and then solve.
        lr2 = lr1 - 0.1
        # print &#39;Guesses:&#39;, lr1, lr2
        self._target = p
        lr1, lr2 = zbracket(self._diff, lr1, lr2)
        # print &#39;Bracket:&#39;, lr1, lr2
        logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
        # print repr(logratio)
        self.probs.append(p)
        self.deltas.append(logratio)
        self.levels.append(self.max+logratio)
        return logratio

    def _diff(self, logratio):
        &#34;&#34;&#34;The function whose zero gives critRatio; it is fracgt - target prob.&#34;&#34;&#34;
        return self.fracgt(logratio) - self._target</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="inference.grid.hpd.HPD2D.p1sig"><code class="name">var <span class="ident">p1sig</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD2D.p2sig"><code class="name">var <span class="ident">p2sig</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD2D.p3sig"><code class="name">var <span class="ident">p3sig</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD2D.ratio1"><code class="name">var <span class="ident">ratio1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD2D.ratio2"><code class="name">var <span class="ident">ratio2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="inference.grid.hpd.HPD2D.ratio3"><code class="name">var <span class="ident">ratio3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="inference.grid.hpd.HPD2D.critlevel"><code class="name flex">
<span>def <span class="ident">critlevel</span></span>(<span>self, p=None, snsig=None, tol=0.0003)</span>
</code></dt>
<dd>
<div class="desc"><p>The log critical PDF ratio (wrt mode) bounding an HPD credible region
with probability p.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def critlevel(self, p=None, snsig=None, tol=3.e-4):
    &#34;&#34;&#34;
    The log critical PDF ratio (wrt mode) bounding an HPD credible region
    with probability p.
    &#34;&#34;&#34;
    # Take as an initial guess the ratio for a 1-d normal.
    if snsig:
        if p:
            raise ValueError(&#39;Provide only one of p, snsig!&#39;)
        lr1 = log(sig2ratio(1, snsig))
        p = sig2prob(1, snsig)
    else:
        lr1 = log(prob2ratio(1, p))
    p = float(p)  # Otherwise it may be a scalar array.
    # Use this to bracket the solution and then solve.
    lr2 = lr1 - 0.1
    # print &#39;Guesses:&#39;, lr1, lr2
    self._target = p
    lr1, lr2 = zbracket(self._diff, lr1, lr2)
    # print &#39;Bracket:&#39;, lr1, lr2
    logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
    # print repr(logratio)
    self.probs.append(p)
    self.deltas.append(logratio)
    self.levels.append(self.max+logratio)
    return logratio</code></pre>
</details>
</dd>
<dt id="inference.grid.hpd.HPD2D.fracgt"><code class="name flex">
<span>def <span class="ident">fracgt</span></span>(<span>self, logratio)</span>
</code></dt>
<dd>
<div class="desc"><p>The fraction of the posterior with log density &gt; maximum + logratio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fracgt(self, logratio):
    &#34;&#34;&#34;
    The fraction of the posterior with log density &gt; maximum + logratio.
    &#34;&#34;&#34;
    ratio = exp(logratio)
    return qgt2d(self.spdf, ratio)*self.dx*self.dy/self.norm</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="inference.grid" href="index.html">inference.grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="inference.grid.hpd.HPD1D" href="#inference.grid.hpd.HPD1D">HPD1D</a></code></h4>
<ul class="two-column">
<li><code><a title="inference.grid.hpd.HPD1D.critlevel" href="#inference.grid.hpd.HPD1D.critlevel">critlevel</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.fracgt" href="#inference.grid.hpd.HPD1D.fracgt">fracgt</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.norm" href="#inference.grid.hpd.HPD1D.norm">norm</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.p1sig" href="#inference.grid.hpd.HPD1D.p1sig">p1sig</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.p2sig" href="#inference.grid.hpd.HPD1D.p2sig">p2sig</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.p3sig" href="#inference.grid.hpd.HPD1D.p3sig">p3sig</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.ratio1" href="#inference.grid.hpd.HPD1D.ratio1">ratio1</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.ratio2" href="#inference.grid.hpd.HPD1D.ratio2">ratio2</a></code></li>
<li><code><a title="inference.grid.hpd.HPD1D.ratio3" href="#inference.grid.hpd.HPD1D.ratio3">ratio3</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="inference.grid.hpd.HPD2D" href="#inference.grid.hpd.HPD2D">HPD2D</a></code></h4>
<ul class="two-column">
<li><code><a title="inference.grid.hpd.HPD2D.critlevel" href="#inference.grid.hpd.HPD2D.critlevel">critlevel</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.fracgt" href="#inference.grid.hpd.HPD2D.fracgt">fracgt</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.p1sig" href="#inference.grid.hpd.HPD2D.p1sig">p1sig</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.p2sig" href="#inference.grid.hpd.HPD2D.p2sig">p2sig</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.p3sig" href="#inference.grid.hpd.HPD2D.p3sig">p3sig</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.ratio1" href="#inference.grid.hpd.HPD2D.ratio1">ratio1</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.ratio2" href="#inference.grid.hpd.HPD2D.ratio2">ratio2</a></code></li>
<li><code><a title="inference.grid.hpd.HPD2D.ratio3" href="#inference.grid.hpd.HPD2D.ratio3">ratio3</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>